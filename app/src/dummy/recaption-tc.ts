export const tc =
  [
    {

      "path": "recaption-application-main/pages/login.tsx",

      "name": "login.tsx",

      "content":

        "import { Button, Checkbox, Flex, FormControl, FormErrorMessage, FormLabel, Input, Link, Text, } from &#39;@chakra-ui/react&#39;; import { useForm, SubmitHandler } from &#39;react-hook-form&#39;; import { Image } from &#39;@chakra-ui/next-js&#39;; import loginService from &#39;../services/login&#39;; import { useRouter } from &#39;next/router&#39;; import { ReactElement, useEffect, useState } from &#39;react&#39;; import axios from &#39;axios&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; import PageLoader from &#39;@/components/PageLoader&#39;; import type { NextPageWithLayout } from &#39;./_app&#39;; type Inputs = { email: string; password: string; }; const version = process.env.NEXT_PUBLIC_APP_VERSION; const Login: NextPageWithLayout = () =&gt; { const router = useRouter(); const { isLoading, isAuthenticated, signIn } = useAuth(); const [validationErrorMessage, setValidationErrorMessage] = useState(&#39;&#39;); useEffect(() =&gt; { if (!isLoading &amp;&amp; isAuthenticated()) { void router.push(&#39;/&#39;); } }, [isLoading, isAuthenticated]); const { register, handleSubmit, formState: { errors }, } = useForm&lt;Inputs&gt;(); if (isLoading || isAuthenticated()) { return &lt;PageLoader /&gt;; } const onSubmit: SubmitHandler&lt;Inputs&gt; = async (data) =&gt; { try { const user = await loginService.login(data); const token = user.data.token; signIn(token); } catch (error: unknown) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { setValidationErrorMessage(error.response?.data.error ?? &#39;&#39;); setTimeout(() =&gt; { setValidationErrorMessage(&#39;&#39;); }, 3000); } } }; if (isLoading || isAuthenticated()) { return &lt;PageLoader /&gt;; } return ( &lt;Flex position={&#39;relative&#39;} minH=&quot;100vh&quot;&gt; &lt;Flex flexDir={&#39;column&#39;} align={&#39;center&#39;} justify=&quot;center&quot; w=&quot;60%&quot; bgColor={&#39;white&#39;} bgGradient={&#39;linear(to-b, #FFFFFF, #D1E7DD)&#39;} &gt; &lt;Image width=&quot;542&quot; height=&quot;350&quot; src={&#39;./magnifier.svg&#39;} alt=&quot;magnifier&quot; /&gt; &lt;Text fontSize=&quot;32&quot; color={&#39;#198754&#39;} mt={16}&gt; Revolutionize data digitization &lt;/Text&gt; &lt;/Flex&gt; &lt;Flex justify={&#39;center&#39;} w=&quot;50%&quot;&gt; &lt;Flex flexDir={&#39;column&#39;} minW=&quot;360px&quot; maxW=&quot;360px&quot; justifyContent={&#39;center&#39;} &gt; &lt;Image alignSelf={&#39;center&#39;} width=&quot;170&quot; height=&quot;30&quot; src={&#39;/logo.png&#39;} alt=&quot;logo&quot; /&gt; &lt;Text mt={6} fontSize={&#39;32&#39;} fontWeight={&#39;500&#39;} as={&#39;h2&#39;} align={&#39;center&#39;} &gt; Log in to your account &lt;/Text&gt; &lt;Text mt={3} fontSize={&#39;16&#39;} align={&#39;center&#39;}&gt; Welcome back! Please enter your details. &lt;/Text&gt; &lt;form onSubmit={handleSubmit(onSubmit)}&gt; &lt;FormControl isInvalid={Boolean(errors.email)}&gt; &lt;Flex flexDir={&#39;column&#39;}&gt; &lt;FormLabel mt={8} htmlFor=&quot;email&quot;&gt; Email &lt;/FormLabel&gt; &lt;Input id=&quot;email&quot; type=&quot;email&quot; placeholder=&quot;Enter your email&quot; {...register(&#39;email&#39;, { required: &#39;Please enter the email.&#39;, pattern: { value: /^[A-Z0-9._%+-]+@[A-Z0-9.-]+\.[A-Z]{2,}$/i, message: &#39;Please enter a valid email.&#39;, }, })} /&gt; &lt;FormErrorMessage&gt; {errors.email &amp;&amp; errors.email.message} &lt;/FormErrorMessage&gt; &lt;/Flex&gt; &lt;/FormControl&gt; &lt;FormControl isInvalid={Boolean(errors.password)}&gt; &lt;Flex flexDir={&#39;column&#39;}&gt; &lt;FormLabel mt={4} htmlFor=&quot;password&quot;&gt; Password &lt;/FormLabel&gt; &lt;Input id=&quot;password&quot; type=&quot;password&quot; placeholder=&quot;Enter your password&quot; {...register(&#39;password&#39;, { required: &#39;Please enter the password.&#39;, })} /&gt; &lt;FormErrorMessage&gt; {errors.password &amp;&amp; errors.password.message} &lt;/FormErrorMessage&gt; &lt;/Flex&gt; &lt;/FormControl&gt; {validationErrorMessage &amp;&amp; ( &lt;Text color={&#39;red.500&#39;} fontSize={&#39;sm&#39;}&gt; {validationErrorMessage} &lt;/Text&gt; )} &lt;Flex mt={6} justify={&#39;space-between&#39;}&gt; &lt;Checkbox colorScheme=&quot;green&quot;&gt;Remember me&lt;/Checkbox&gt; &lt;Link color=&quot;green.400&quot; href=&quot;/forgot-password&quot;&gt; Forgot password &lt;/Link&gt; &lt;/Flex&gt; &lt;Button mt={4} w={&#39;full&#39;} bgColor={&#39;green.400&#39;} color={&#39;white&#39;} type=&quot;submit&quot; _hover={{ bgColor: &#39;green.500&#39; }} &gt; Log In &lt;/Button&gt; &lt;/form&gt; &lt;/Flex&gt; &lt;/Flex&gt; &lt;Text pos={&#39;absolute&#39;} left={&#39;50%&#39;} transform={&#39;translate(-50%, 0)&#39;} bottom={1} &gt; v{version} Â© lapis.ai - 2023 &lt;/Text&gt; &lt;/Flex&gt; ); }; Login.getLayout = function getLayout(page: ReactElement) { return page; }; export default Login; "

    },
    
    {

      "path": "recaption-application-main/pages/404.tsx",

      "name": "404.tsx",

      "content":

        "import { Flex, Text } from &#39;@chakra-ui/react&#39;; type Props = { message?: string; height?: string; }; export default function Error404({ message, height }: Props) { return ( &lt;Flex minH={height ? height : &#39;100vh&#39;} justify={&#39;center&#39;} align={&#39;center&#39;} flexDir={&#39;column&#39;} &gt; &lt;Text fontSize={&#39;9xl&#39;}&gt;404&lt;/Text&gt; &lt;Text fontSize={&#39;4xl&#39;}&gt;{message ? message : &#39;Not Found&#39;}&lt;/Text&gt; &lt;/Flex&gt; ); } Error404.getLayout = function getLayout(page: React.ReactElement) { return page; }; "

    },

    {

      "path": "recaption-application-main/pages/index.tsx",

      "name": "index.tsx",

      "content":

        "import Head from &#39;next/head&#39;; import { Container, Flex, Text } from &#39;@chakra-ui/react&#39;; import DocumentCard from &#39;@/components/DocumentCard&#39;; import { useEffect, useRef, useState } from &#39;react&#39;; import FileHistoryTable from &#39;@/components/FileHistoryTable&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; import resultService from &#39;@/services/result&#39;; import { useQuery } from &#39;react-query&#39;; export default function Home() { const { isLoading, isAuthenticated, getToken } = useAuth(); const cardContainer = useRef&lt;HTMLDivElement&gt;(null); const [historyTable, setHistoryTable] = useState&lt;TableResult[]&gt;([]); const { isLoading: _isLoadingQuery, error: _error, data: results, } = useQuery(&#39;results&#39;, () =&gt; resultService.getAllTableResult(getToken())); useEffect(() =&gt; { function initTable() { setHistoryTable(results?.data as TableResult[]); } if (!isLoading &amp;&amp; isAuthenticated()) { void initTable(); } }, [isLoading, isAuthenticated, results]); return ( &lt;&gt; &lt;Head&gt; &lt;title&gt;RECAPTION&lt;/title&gt; &lt;meta name=&quot;description&quot; content=&quot;Recaption Application&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width, initial-scale=1&quot; /&gt; &lt;link rel=&quot;icon&quot; href=&quot;/favicon.ico&quot; /&gt; &lt;/Head&gt; &lt;Flex flexDir={&#39;column&#39;} bgGradient={&#39;linear(to-b, #DCF3E1 20%, #FFFFFF)&#39;} &gt; &lt;Container maxW=&quot;container.xl&quot; flexDir={&#39;column&#39;} minH={&#39;calc(100vh - 80px)&#39;} pb={8} &gt; &lt;Text mt=&quot;116px&quot; align={&#39;center&#39;} fontSize={32} color={&#39;green.600&#39;} fontWeight={500} &gt; Lets digitize your documents! Upload them here to get started. &lt;/Text&gt; &lt;Flex ref={cardContainer} mt=&quot;100px&quot; flexDir={&#39;column&#39;}&gt; &lt;Flex gap={6} justify={&#39;center&#39;}&gt; &lt;DocumentCard icon={&#39;./document-thumbnail/ktp.svg&#39;} title=&quot;KTP&quot; type=&quot;ktp&quot; /&gt; &lt;DocumentCard icon={&#39;./document-thumbnail/npwp.svg&#39;} title=&quot;NPWP&quot; type=&quot;npwp&quot; /&gt; &lt;DocumentCard icon={&#39;./document-thumbnail/pajak.svg&#39;} title=&quot;Faktur Pajak&quot; type=&quot;pajak&quot; /&gt; &lt;/Flex&gt; &lt;Flex gap={6} mt={6} justify={&#39;center&#39;}&gt; &lt;DocumentCard icon={&#39;./document-thumbnail/bast.svg&#39;} title=&quot;Passport&quot; type=&quot;passport&quot; /&gt; &lt;DocumentCard icon={&#39;./document-thumbnail/invoice.svg&#39;} title=&quot;Invoice&quot; type=&quot;invoice&quot; /&gt; &lt;/Flex&gt; &lt;/Flex&gt; &lt;FileHistoryTable dataTable={historyTable} /&gt; &lt;/Container&gt; &lt;/Flex&gt; &lt;/&gt; ); } "

    },

    {

      "path": "recaption-application-main/pages/_document.tsx",

      "name": "_document.tsx",

      "content":

        "import { Html, Head, Main, NextScript } from &#39;next/document&#39;; export default function Document() { return ( &lt;Html lang=&quot;en&quot;&gt; &lt;Head /&gt; &lt;body&gt; &lt;Main /&gt; &lt;NextScript /&gt; &lt;/body&gt; &lt;/Html&gt; ); } "

    },

    {

      "path": "recaption-application-main/pages/reset-password.tsx",

      "name": "reset-password.tsx",

      "content":

        "import PageWrapper from &#39;@/components/PageWrapper&#39;; import { Flex, FormControl, FormLabel, Input, FormErrorMessage, Button, useToast, Text, } from &#39;@chakra-ui/react&#39;; import { useRouter } from &#39;next/router&#39;; import { SubmitHandler, useForm } from &#39;react-hook-form&#39;; import userService from &#39;@/services/user&#39;; import axios from &#39;axios&#39;; import { deleteCookie } from &#39;cookies-next&#39;; import Link from &#39;next/link&#39;; import { useState } from &#39;react&#39;; type ResetPasswordInputs = { password: string; confirmPassword: string; }; export default function ResetPassword() { const router = useRouter(); const resetPasswordToken = router.query.token as string; const toast = useToast(); const [isSuccess, setIsSuccess] = useState(false); deleteCookie(&#39;authToken&#39;); const { register, handleSubmit, formState: { errors: errors }, watch, } = useForm&lt;ResetPasswordInputs&gt;(); const onSubmit: SubmitHandler&lt;ResetPasswordInputs&gt; = async (data) =&gt; { try { const res = await userService.resetPasswordWithToken({ ...data, token: resetPasswordToken, }); toast({ description: res.message, status: &#39;success&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); setIsSuccess(true); } catch (error: unknown) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { toast({ description: error.response?.data.error ?? &#39;&#39;, status: &#39;error&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); } } }; const resetPasswordForm = ( &lt;form onSubmit={handleSubmit(onSubmit)}&gt; &lt;Flex flexDir={&#39;column&#39;} w={96}&gt; &lt;FormControl isInvalid={Boolean(errors.password)}&gt; &lt;FormLabel htmlFor=&quot;password&quot;&gt;Password&lt;/FormLabel&gt; &lt;Input id=&quot;password&quot; type=&quot;password&quot; {...register(&#39;password&#39;, { required: &#39;Password is required&#39;, })} /&gt; &lt;FormErrorMessage&gt; {errors.password &amp;&amp; errors.password.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;FormControl mt={6} isInvalid={Boolean(errors.confirmPassword)}&gt; &lt;FormLabel htmlFor=&quot;confirm-password&quot;&gt;Confirm Password&lt;/FormLabel&gt; &lt;Input id=&quot;confirm-password&quot; type=&quot;password&quot; {...register(&#39;confirmPassword&#39;, { required: &#39;Confirm Password is required&#39;, validate: (val: string) =&gt; { if (watch(&#39;password&#39;) != val) { return &#39;Your passwords do not match&#39;; } }, })} /&gt; &lt;FormErrorMessage&gt; {errors.confirmPassword &amp;&amp; errors.confirmPassword.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;Button mt={8} variant=&quot;outline-primary&quot; type=&quot;submit&quot;&gt; Submit &lt;/Button&gt; &lt;/Flex&gt; &lt;/form&gt; ); const successMessage = ( &lt;Text mt={16} fontSize={&#39;lg&#39;} textAlign={&#39;center&#39;}&gt; Your password has been reset successfully. Click{&#39; &#39;} &lt;Link href={&#39;/login&#39;}&gt; &lt;Text color={&#39;green&#39;} as={&#39;u&#39;}&gt; here &lt;/Text&gt; &lt;/Link&gt;{&#39; &#39;} to login with your new password. &lt;/Text&gt; ); return ( &lt;Flex bg={&#39;#DCF3E1&#39;} h={&#39;100vh&#39;} alignItems={&#39;center&#39;}&gt; &lt;PageWrapper title={&#39;Input Your New Password&#39;}&gt; &lt;Flex w={&#39;full&#39;} justify={&#39;center&#39;} mt={16}&gt; {!isSuccess ? resetPasswordForm : successMessage} &lt;/Flex&gt; &lt;/PageWrapper&gt; &lt;/Flex&gt; ); } ResetPassword.getInitialProps = () =&gt; { return { skipAuth: true }; }; "

    },

    {

      "path": "recaption-application-main/pages/forgot-password.tsx",

      "name": "forgot-password.tsx",

      "content":

        "import PageWrapper from &#39;@/components/PageWrapper&#39;; import { Button } from &#39;@chakra-ui/button&#39;; import { Text } from &#39;@chakra-ui/layout&#39;; import { FormControl, FormLabel, FormErrorMessage, } from &#39;@chakra-ui/form-control&#39;; import { Input } from &#39;@chakra-ui/input&#39;; import { Flex } from &#39;@chakra-ui/layout&#39;; import { SubmitHandler, useForm } from &#39;react-hook-form&#39;; import axios from &#39;axios&#39;; import { useToast } from &#39;@chakra-ui/toast&#39;; import { useState } from &#39;react&#39;; import { deleteCookie } from &#39;cookies-next&#39;; import authService from &#39;@/services/auth&#39;; type EmailFormInputs = { email: string; }; export default function ForgotPassword() { const toast = useToast(); const [isSubmitted, setIsSubmitted] = useState(false); const [email, setEmail] = useState(&#39;&#39;); const { register, handleSubmit, formState: { errors: errors }, } = useForm&lt;EmailFormInputs&gt;(); deleteCookie(&#39;authToken&#39;); const onSubmitEmail: SubmitHandler&lt;EmailFormInputs&gt; = async (data) =&gt; { try { setEmail(data.email); setIsSubmitted(true); const res = await authService.forgotPassword({ email: data.email, }); toast({ description: res.message, status: &#39;success&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); } catch (error: unknown) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { let errorMessage = &#39;&#39;; if (error.response?.data.error === &#39;Invalid email or password&#39;) { errorMessage = &#39;Invalid password&#39;; } toast({ description: errorMessage, status: &#39;error&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); } } }; const emailForm = ( &lt;form onSubmit={handleSubmit(onSubmitEmail)}&gt; &lt;Flex flexDir={&#39;column&#39;} w={96}&gt; &lt;FormControl isInvalid={Boolean(errors.email)}&gt; &lt;FormLabel htmlFor=&quot;email&quot;&gt;Email&lt;/FormLabel&gt; &lt;Input id=&quot;email&quot; type=&quot;email&quot; {...register(&#39;email&#39;, { required: &#39;Email is required&#39;, })} /&gt; &lt;FormErrorMessage&gt; {errors.email &amp;&amp; errors.email.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;Button mt={8} variant=&quot;outline-primary&quot; type=&quot;submit&quot;&gt; Submit &lt;/Button&gt; &lt;/Flex&gt; &lt;/form&gt; ); const afterSubmitEmail = ( &lt;Flex flexDir={&#39;column&#39;} mt={16}&gt; &lt;Text textAlign={&#39;center&#39;} fontSize={&#39;lg&#39;}&gt; We wanted to let you know that an email has been sent to the address associated with your account on &lt;strong&gt;{email}&lt;/strong&gt;. This email contains instructions on how to reset your password. &lt;/Text&gt; &lt;br /&gt; &lt;Text textAlign={&#39;center&#39;} fontSize={&#39;lg&#39;}&gt; If you do not see the email in your inbox, please check your spam or junk folder, as it might have been filtered there. &lt;/Text&gt; &lt;/Flex&gt; ); return ( &lt;Flex bg={&#39;#DCF3E1&#39;} h={&#39;100vh&#39;} alignItems={&#39;center&#39;}&gt; &lt;PageWrapper title={!isSubmitted ? &#39;Input Your Email&#39; : &#39;Email has been sent&#39;} &gt; &lt;Flex w={&#39;full&#39;} justify={&#39;center&#39;} mt={16}&gt; {!isSubmitted ? emailForm : afterSubmitEmail} &lt;/Flex&gt; &lt;/PageWrapper&gt; &lt;/Flex&gt; ); } ForgotPassword.getInitialProps = () =&gt; { return { skipAuth: true }; }; "

    },

    {

      "path": "recaption-application-main/pages/_app.tsx",

      "name": "_app.tsx",

      "content":

        "import type { AppProps } from &#39;next/app&#39;; import { ChakraProvider } from &#39;@chakra-ui/react&#39;; import { theme } from &#39;@/styles/theme&#39;; import { AuthProvider } from &#39;@/contexts/AuthContext&#39;; import Layout from &#39;@/components/Layout&#39;; import type { NextPage } from &#39;next&#39;; import type { ReactElement, ReactNode } from &#39;react&#39;; import { QueryClient, QueryClientProvider } from &#39;react-query&#39;; export type NextPageWithLayout&lt;P = object, IP = P&gt; = NextPage&lt;P, IP&gt; &amp; { getLayout?: (page: ReactElement) =&gt; ReactNode; }; type PagePropsConfig = { skipAuth?: boolean; }; type AppPropsWithLayout = AppProps&lt;PagePropsConfig&gt; &amp; { Component: NextPageWithLayout; pageProps: { skipAuth?: boolean; }; }; const queryClient = new QueryClient(); export default function App({ Component, pageProps }: AppPropsWithLayout) { const getLayout = Component.getLayout ?? ((page) =&gt; &lt;Layout&gt;{page}&lt;/Layout&gt;); const skipAuth = pageProps.skipAuth || false; return ( &lt;ChakraProvider theme={theme}&gt; &lt;QueryClientProvider client={queryClient}&gt; {skipAuth ? ( &lt;Component {...pageProps} /&gt; ) : ( &lt;AuthProvider&gt;{getLayout(&lt;Component {...pageProps} /&gt;)}&lt;/AuthProvider&gt; )} &lt;/QueryClientProvider&gt; &lt;/ChakraProvider&gt; ); } "

    },

    {

      "path": "recaption-application-main/pages/recognizer-result/[fileId].tsx",

      "name": "[fileId].tsx",

      "content":

        "import { Breadcrumb, BreadcrumbItem, BreadcrumbLink, Flex, Text, Image, useToast, } from &#39;@chakra-ui/react&#39;; import ResultBoundingBox from &#39;@/components/recognizer-result/ResultBoundingBox&#39;; import ResultRightContainer from &#39;@/components/recognizer-result/ResultRightContainer&#39;; import { useEffect, useState } from &#39;react&#39;; import { useRouter } from &#39;next/router&#39;; import Link from &#39;next/link&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; import axios from &#39;axios&#39;; import Error404 from &#39;../404&#39;; import resultService from &#39;@/services/result&#39;; import Head from &#39;next/head&#39;; import { parseFileName } from &#39;@/lib/file&#39;; import { useFileStore, useResultStore } from &#39;@/stores&#39;; /** * Display recognizer result left panel (document image and the bounding box) */ export default function RecognizerResult() { const router = useRouter(); const toast = useToast(); const { isLoading, isAuthenticated, getToken } = useAuth(); const fileUrl = useFileStore((state) =&gt; state.fileUrl); const setFileUrl = useFileStore((state) =&gt; state.setFileUrl); const [isError, setIsError] = useState&lt;boolean&gt;(false); const [isDoneFecthing, setIsDoneFetching] = useState&lt;boolean&gt;(false); const result = useResultStore((state) =&gt; state.result); const setResult = useResultStore((state) =&gt; state.setResult); const setDocumentType = useFileStore((state) =&gt; state.setDocumentType); const { fileId } = router.query; useEffect(() =&gt; { async function getResult() { try { const result = await resultService.getSingleFileResult( getToken(), fileId as string ); setResult(result.data.formattedContent); setFileUrl(result.data.file.filePath); setDocumentType(result.data.file.fileType); } catch (error) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { if (error.response?.status === 401) { toast({ description: error.response?.data.error, status: &#39;error&#39;, isClosable: true, position: &#39;top&#39;, duration: 5000, }); } else { setIsError(true); } } } finally { setIsDoneFetching(true); } } if (!isLoading &amp;&amp; isAuthenticated()) { if (fileId) { void getResult(); } } }, [isLoading, isAuthenticated]); const resultElement = ( &lt;&gt; &lt;Head&gt; &lt;title key={fileUrl}&gt;{parseFileName(fileUrl)}&lt;/title&gt; &lt;/Head&gt; &lt;Flex flexDir={&#39;column&#39;} px={&#39;72px&#39;}&gt; &lt;Breadcrumb color={&#39;gray.600&#39;}&gt; &lt;BreadcrumbItem&gt; &lt;BreadcrumbLink href=&quot;/&quot;&gt; &lt;Flex align={&#39;center&#39;}&gt; &lt;Flex mr={1}&gt; &lt;Image width={&#39;12px&#39;} height={&#39;12px&#39;} src={&#39;/house.svg&#39;} alt=&quot;house&quot; /&gt; &lt;/Flex&gt; &lt;Text&gt;Home&lt;/Text&gt; &lt;/Flex&gt; &lt;/BreadcrumbLink&gt; &lt;/BreadcrumbItem&gt; &lt;BreadcrumbItem&gt; &lt;BreadcrumbLink href=&quot;/recognizer-result&quot;&gt; Recognizer Result &lt;/BreadcrumbLink&gt; &lt;/BreadcrumbItem&gt; &lt;/Breadcrumb&gt; &lt;Flex mt={4}&gt; &lt;Link href={&#39;/&#39;}&gt; &lt;Flex mr={2} align={&#39;center&#39;}&gt; &lt;Image width={&#39;26px&#39;} height={&#39;26px&#39;} src={&#39;/left-arrow.svg&#39;} alt=&quot;left-arrow&quot; /&gt; &lt;Text fontSize={20} fontWeight={500} mt={-0.5}&gt; Recognizer Result &lt;/Text&gt; &lt;/Flex&gt; &lt;/Link&gt; &lt;/Flex&gt; &lt;Flex mt={2} justify={&#39;center&#39;}&gt; &lt;ResultBoundingBox fileUrl={fileUrl} /&gt; &lt;ResultRightContainer result={result} /&gt; &lt;/Flex&gt; &lt;/Flex&gt; &lt;/&gt; ); if (isError &amp;&amp; isDoneFecthing) { return &lt;Error404 height=&quot;calc(100vh - 161px)&quot; message=&quot;Result not found&quot; /&gt;; } else if (!isError &amp;&amp; isDoneFecthing) { return resultElement; } return &lt;Flex minH={&#39;calc(100vh - 161px)&#39;}&gt;&lt;/Flex&gt;; } "

    },

    {

      "path": "recaption-application-main/pages/profile/[userId].tsx",

      "name": "[userId].tsx",

      "content":

        "import { useAuth } from &#39;@/contexts/AuthContext&#39;; import { useRouter } from &#39;next/router&#39;; import userService from &#39;@/services/user&#39;; import { useQuery } from &#39;react-query&#39;; import { Flex, Text } from &#39;@chakra-ui/react&#39;; import ProfileForm from &#39;@/components/ProfileForm&#39;; import { useEffect } from &#39;react&#39;; import PageLoader from &#39;@/components/PageLoader&#39;; import PageWrapper from &#39;@/components/PageWrapper&#39;; export default function Profile() { const router = useRouter(); const { getToken, getUser, isLoading: isLoadingAuth, isAuthenticated, } = useAuth(); const currentUserId = getUser().id; const currentRole = getUser().role; const urlUserId = router.query.userId as string; useEffect(() =&gt; { if (!isLoadingAuth &amp;&amp; !isAuthenticated()) { void router.push(&#39;/login&#39;); } }, [isLoadingAuth, isAuthenticated]); const { isLoading, error: _error, data, } = useQuery([&#39;user&#39;, urlUserId], () =&gt; userService.getSingleUser(getToken(), urlUserId) ); const profileElement = ( &lt;PageWrapper title={&#39;Profile&#39;}&gt; {!isLoading &amp;&amp; data &amp;&amp; &lt;ProfileForm user={data.data} /&gt;} &lt;/PageWrapper&gt; ); if (isLoadingAuth || !isAuthenticated()) { return &lt;PageLoader /&gt;; } else { if (currentUserId &amp;&amp; urlUserId &amp;&amp; currentRole) { if (currentUserId !== urlUserId &amp;&amp; currentRole !== &#39;admin&#39;) { return ( &lt;Flex justify={&#39;center&#39;}&gt; &lt;Text mt={20} fontSize={&#39;2xl&#39;}&gt; Unauthorized. You can not access this page. &lt;/Text&gt; &lt;/Flex&gt; ); } else { return profileElement; } } } } "

    },

    {

      "path": "recaption-application-main/pages/management/index.tsx",

      "name": "index.tsx",

      "content":

        "import { WithProtectedAdmin } from &#39;@/components/WithProtectedAdmin&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; import { Button, HStack, Link, Table, Tbody, Td, Th, Thead, Tr, } from &#39;@chakra-ui/react&#39;; import { createColumnHelper, useReactTable, getCoreRowModel, flexRender, } from &#39;@tanstack/react-table&#39;; import userService from &#39;@/services/user&#39;; import { useQuery } from &#39;react-query&#39;; import PageWrapper from &#39;@/components/PageWrapper&#39;; function Management() { const { getToken } = useAuth(); const columnHelper = createColumnHelper&lt;User&gt;(); const { isLoading: _isLoadingQuery, error: _error, data: allUser, } = useQuery(&#39;allUser&#39;, () =&gt; userService.getAllUser(getToken())); const data = (allUser?.data as User[]) || []; const columns = [ columnHelper.accessor(&#39;email&#39;, { header: &#39;Email&#39;, }), columnHelper.accessor(&#39;username&#39;, { header: &#39;Username&#39;, }), columnHelper.accessor(&#39;role&#39;, { header: &#39;Role&#39;, }), columnHelper.accessor(&#39;quota&#39;, { header: &#39;Quota&#39;, }), columnHelper.accessor(&#39;limit&#39;, { header: &#39;Limit&#39;, }), columnHelper.display({ header: &#39;Actions&#39;, cell: (info) =&gt; ( &lt;HStack&gt; &lt;Link href={`/profile/${info.row.original.id}`} target=&quot;_blank&quot;&gt; &lt;Button variant={&#39;outline-primary&#39;} borderRadius={4} size={&#39;sm&#39;}&gt; Edit &lt;/Button&gt; &lt;/Link&gt; &lt;/HStack&gt; ), }), ]; const table = useReactTable({ data, columns, getCoreRowModel: getCoreRowModel(), }); return ( &lt;PageWrapper title={&#39;User List&#39;}&gt; &lt;Link href={&#39;/management/new-user&#39;} target=&quot;_blank&quot;&gt; &lt;Button variant={&#39;outline-primary&#39;} w={&#39;fit-content&#39;}&gt; Create new user &lt;/Button&gt; &lt;/Link&gt; &lt;Table border={&#39;1px&#39;} borderBottom={&#39;2px&#39;} borderColor={&#39;gray.400&#39;} w={&#39;full&#39;} bg={&#39;white&#39;} mt={4} &gt; &lt;Thead bg={&#39;gray.200&#39;}&gt; {table.getHeaderGroups().map((headerGroup) =&gt; ( &lt;Tr key={headerGroup.id}&gt; {headerGroup.headers.map((header) =&gt; ( &lt;Th key={header.id} color={&#39;black&#39;}&gt; {header.isPlaceholder ? null : flexRender( header.column.columnDef.header, header.getContext() )} &lt;/Th&gt; ))} &lt;/Tr&gt; ))} &lt;/Thead&gt; &lt;Tbody&gt; {table.getRowModel().rows.map((row) =&gt; ( &lt;Tr key={row.id}&gt; {row.getVisibleCells().map((cell) =&gt; ( &lt;Td key={cell.id} wordBreak={&#39;break-word&#39;}&gt; {flexRender(cell.column.columnDef.cell, cell.getContext())} &lt;/Td&gt; ))} &lt;/Tr&gt; ))} &lt;/Tbody&gt; &lt;/Table&gt; &lt;/PageWrapper&gt; ); } export default WithProtectedAdmin(Management); "

    },

    {

      "path": "recaption-application-main/pages/management/new-user.tsx",

      "name": "new-user.tsx",

      "content":

        "import PageWrapper from &#39;@/components/PageWrapper&#39;; import { Flex, Button, FormControl, FormErrorMessage, FormLabel, HStack, Input, SimpleGrid, useToast, } from &#39;@chakra-ui/react&#39;; import { SubmitHandler, useForm } from &#39;react-hook-form&#39;; import userService from &#39;@/services/user&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; import axios from &#39;axios&#39;; export type ProfileFormProps = { user: User; }; type ProfileFormInputs = Omit&lt;User, &#39;id&#39; | &#39;role&#39;&gt;; export default function NewUser() { const { getToken, getUser } = useAuth(); const signedRole = getUser().role; const toast = useToast(); const { register, handleSubmit, formState: { errors: errors }, reset, } = useForm&lt;ProfileFormInputs&gt;({ defaultValues: { quota: &#39;100&#39;, limit: &#39;100&#39;, }, }); const onSubmit: SubmitHandler&lt;ProfileFormInputs&gt; = async (data) =&gt; { try { const res = await userService.createUserByAdmin(getToken(), { ...data, quota: Number(data.quota), limit: Number(data.limit), }); toast({ description: res.message, status: &#39;success&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); } catch (error: unknown) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { toast({ description: error.response?.data.error ?? &#39;&#39;, status: &#39;error&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); } } }; return ( &lt;PageWrapper title={&#39;Create New User&#39;}&gt; &lt;form onSubmit={handleSubmit(onSubmit)} style={{ width: &#39;100%&#39; }}&gt; &lt;Flex flexDir={&#39;column&#39;}&gt; &lt;SimpleGrid columns={2} spacing={8}&gt; &lt;FormControl isInvalid={Boolean(errors.username)}&gt; &lt;FormLabel htmlFor=&quot;username&quot;&gt;Username&lt;/FormLabel&gt; &lt;Input id=&quot;username&quot; type=&quot;text&quot; {...register(&#39;username&#39;, { required: &#39;Username is required&#39; })} /&gt; &lt;FormErrorMessage&gt; {errors.username &amp;&amp; errors.username.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;FormControl isInvalid={Boolean(errors.email)}&gt; &lt;FormLabel&gt;Email&lt;/FormLabel&gt; &lt;Input type=&quot;email&quot; {...register(&#39;email&#39;, { required: &#39;Email is required&#39; })} /&gt; &lt;FormErrorMessage&gt; {errors.email &amp;&amp; errors.email.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;FormControl isInvalid={Boolean(errors.quota)}&gt; &lt;FormLabel&gt;Quota&lt;/FormLabel&gt; &lt;Input type=&quot;text&quot; {...register(&#39;quota&#39;, { disabled: signedRole === &#39;admin&#39; ? false : true, required: &#39;Quota is required&#39;, })} /&gt; &lt;FormErrorMessage&gt; {errors.quota &amp;&amp; errors.quota.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;FormControl isInvalid={Boolean(errors.limit)}&gt; &lt;FormLabel&gt;Limit&lt;/FormLabel&gt; &lt;Input type=&quot;text&quot; {...register(&#39;limit&#39;, { disabled: signedRole === &#39;admin&#39; ? false : true, required: &#39;Limit is required&#39;, })} /&gt; &lt;FormErrorMessage&gt; {errors.limit &amp;&amp; errors.limit.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;/SimpleGrid&gt; &lt;HStack mt={4} spacing={4} alignSelf={&#39;flex-end&#39;}&gt; &lt;Button variant=&quot;outline-red&quot; onClick={() =&gt; { reset(); }} &gt; Reset &lt;/Button&gt; &lt;Button variant=&quot;outline-primary&quot; type=&quot;submit&quot;&gt; Create &lt;/Button&gt; &lt;/HStack&gt; &lt;/Flex&gt; &lt;/form&gt; &lt;/PageWrapper&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/Navbar.tsx",

      "name": "Navbar.tsx",

      "content":

        "import { useAuth } from &#39;@/contexts/AuthContext&#39;; import { Avatar, Button, Flex, Menu, MenuButton, MenuDivider, MenuItem, MenuList, Text, Image, Icon, } from &#39;@chakra-ui/react&#39;; import Link from &#39;next/link&#39;; import { AiOutlineApartment } from &#39;react-icons/ai&#39;; export default function Navbar() { const { signOut, getUser } = useAuth(); const role = getUser().role; const userId = getUser().id; const username = getUser().name; const isAdmin = role === &#39;admin&#39;; function handleLogout() { signOut(); } return ( &lt;Flex flexDir={&#39;column&#39;} bg={&#39;white&#39;}&gt; &lt;Flex minH={&#39;72px&#39;} maxH={&#39;72px&#39;} w={&#39;full&#39;} align={&#39;center&#39;} justify={&#39;space-between&#39;} px={6} borderBottom={&#39;1px&#39;} borderColor={&#39;gray.300&#39;} &gt; &lt;Link href={&#39;/&#39;}&gt; &lt;Image width={&#39;170px&#39;} height={&#39;30px&#39;} src={&#39;/logo.png&#39;} alt=&quot;logo&quot; /&gt; &lt;/Link&gt; &lt;Flex h={&#39;40px&#39;} align={&#39;center&#39;}&gt; &lt;Flex px={3}&gt; &lt;Link href={&#39;/&#39;}&gt; &lt;Image width={&#39;20px&#39;} height={&#39;20px&#39;} src={&#39;/house.svg&#39;} alt=&quot;house&quot; /&gt; &lt;/Link&gt; &lt;/Flex&gt; &lt;Flex px={3}&gt; &lt;Image width={&#39;20px&#39;} height={&#39;20px&#39;} src={&#39;/bell.svg&#39;} alt=&quot;bell&quot; /&gt; &lt;/Flex&gt; &lt;Text pl={3} pr={2}&gt; {username} &lt;/Text&gt; &lt;Flex alignItems={&#39;center&#39;}&gt; &lt;Menu&gt; &lt;MenuButton as={Button} data-cy=&quot;profile-image&quot; rounded={&#39;full&#39;} variant={&#39;link&#39;} cursor={&#39;pointer&#39;} &gt; &lt;Avatar ml={3} w={&#39;40px&#39;} h={&#39;40px&#39;} /&gt; &lt;/MenuButton&gt; &lt;MenuList mt={2}&gt; &lt;Link href={`/profile/${userId}`}&gt; &lt;MenuItem pl={4} py={3}&gt; &lt;Image width={&#39;20px&#39;} height={&#39;20px&#39;} src={&#39;/person.svg&#39;} alt=&quot;person&quot; /&gt; &lt;Text ml={3}&gt;Profile&lt;/Text&gt; &lt;/MenuItem&gt; &lt;/Link&gt; &lt;MenuDivider my={0} /&gt; {isAdmin &amp;&amp; ( &lt;&gt; &lt;Link href={&#39;/management&#39;} passHref&gt; &lt;MenuItem pl={4} py={3}&gt; &lt;Icon as={AiOutlineApartment} w={&#39;20px&#39;} h={&#39;20px&#39;} /&gt; &lt;Text ml={3}&gt;Management&lt;/Text&gt; &lt;/MenuItem&gt; &lt;/Link&gt; &lt;MenuDivider my={0} /&gt; &lt;/&gt; )} &lt;MenuItem pl={4} py={3}&gt; &lt;Image width={&#39;20px&#39;} height={&#39;20px&#39;} src={&#39;/help.svg&#39;} alt=&quot;help&quot; /&gt; &lt;Text ml={3}&gt;Help Center&lt;/Text&gt; &lt;/MenuItem&gt; &lt;MenuDivider my={0} /&gt; &lt;MenuItem pl={4} py={3} onClick={handleLogout}&gt; &lt;Image width={&#39;20px&#39;} height={&#39;20px&#39;} src={&#39;/exit.svg&#39;} alt=&quot;exit&quot; /&gt; &lt;Text ml={3}&gt;Logout&lt;/Text&gt; &lt;/MenuItem&gt; &lt;/MenuList&gt; &lt;/Menu&gt; &lt;/Flex&gt; &lt;/Flex&gt; &lt;/Flex&gt; &lt;/Flex&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/ChangeFileIcon.tsx",

      "name": "ChangeFileIcon.tsx",

      "content":

        "import styles from &#39;@/styles/ChangeFileIcon.module.css&#39;; export default function ChangeFileIcon() { return ( &lt;svg width=&quot;16&quot; height=&quot;17&quot; viewBox=&quot;0 0 16 17&quot; fill=&quot;none&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; className={styles.icon} &gt; &lt;g clipPath=&quot;url(#clip0_141_202468)&quot;&gt; &lt;rect width=&quot;16&quot; height=&quot;16&quot; transform=&quot;translate(0 0.5)&quot; fill=&quot;white&quot; fillOpacity=&quot;0.01&quot; /&gt; &lt;g clipPath=&quot;url(#clip1_141_202468)&quot;&gt; &lt;path d=&quot;M0.5 10.3992C0.632608 10.3992 0.759785 10.4519 0.853553 10.5456C0.947322 10.6394 1 10.7666 1 10.8992V13.3992C1 13.6644 1.10536 13.9188 1.29289 14.1063C1.48043 14.2938 1.73478 14.3992 2 14.3992H14C14.2652 14.3992 14.5196 14.2938 14.7071 14.1063C14.8946 13.9188 15 13.6644 15 13.3992V10.8992C15 10.7666 15.0527 10.6394 15.1464 10.5456C15.2402 10.4519 15.3674 10.3992 15.5 10.3992C15.6326 10.3992 15.7598 10.4519 15.8536 10.5456C15.9473 10.6394 16 10.7666 16 10.8992V13.3992C16 13.9296 15.7893 14.4383 15.4142 14.8134C15.0391 15.1885 14.5304 15.3992 14 15.3992H2C1.46957 15.3992 0.960859 15.1885 0.585786 14.8134C0.210714 14.4383 0 13.9296 0 13.3992V10.8992C0 10.7666 0.0526784 10.6394 0.146447 10.5456C0.240215 10.4519 0.367392 10.3992 0.5 10.3992Z&quot; fill=&quot;#479F76&quot; /&gt; &lt;path d=&quot;M7.646 1.64518C7.69245 1.59862 7.74762 1.56168 7.80837 1.53647C7.86911 1.51127 7.93423 1.49829 8 1.49829C8.06577 1.49829 8.13089 1.51127 8.19163 1.53647C8.25238 1.56168 8.30755 1.59862 8.354 1.64518L11.354 4.64518C11.4479 4.73907 11.5006 4.86641 11.5006 4.99918C11.5006 5.13196 11.4479 5.2593 11.354 5.35318C11.2601 5.44707 11.1328 5.49982 11 5.49982C10.8672 5.49982 10.7399 5.44707 10.646 5.35318L8.5 3.20618V11.9992C8.5 12.1318 8.44732 12.259 8.35355 12.3527C8.25979 12.4465 8.13261 12.4992 8 12.4992C7.86739 12.4992 7.74021 12.4465 7.64645 12.3527C7.55268 12.259 7.5 12.1318 7.5 11.9992V3.20618L5.354 5.35318C5.30751 5.39967 5.25232 5.43655 5.19158 5.46171C5.13084 5.48687 5.06574 5.49982 5 5.49982C4.93426 5.49982 4.86916 5.48687 4.80842 5.46171C4.74768 5.43655 4.69249 5.39967 4.646 5.35318C4.59951 5.3067 4.56264 5.25151 4.53748 5.19077C4.51232 5.13003 4.49937 5.06493 4.49937 4.99918C4.49937 4.93344 4.51232 4.86834 4.53748 4.8076C4.56264 4.74686 4.59951 4.69167 4.646 4.64518L7.646 1.64518Z&quot; fill=&quot;#479F76&quot; /&gt; &lt;/g&gt; &lt;/g&gt; &lt;defs&gt; &lt;clipPath id=&quot;clip0_141_202468&quot;&gt; &lt;rect width=&quot;16&quot; height=&quot;16&quot; fill=&quot;white&quot; transform=&quot;translate(0 0.5)&quot; /&gt; &lt;/clipPath&gt; &lt;clipPath id=&quot;clip1_141_202468&quot;&gt; &lt;rect width=&quot;16&quot; height=&quot;16&quot; fill=&quot;white&quot; transform=&quot;translate(0 0.5)&quot; /&gt; &lt;/clipPath&gt; &lt;/defs&gt; &lt;/svg&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/FilePreviewModal.tsx",

      "name": "FilePreviewModal.tsx",

      "content":

        "import { useAuth } from &#39;@/contexts/AuthContext&#39;; import { apiInstance } from &#39;@/lib/apiInstance&#39;; import { getFileExtensionFromPath } from &#39;@/lib/file&#39;; import trimPath from &#39;@/lib/util/trimPath&#39;; import { Modal, ModalOverlay, ModalContent, ModalHeader, ModalCloseButton, ModalBody, ModalFooter, Button, Image, useToast, } from &#39;@chakra-ui/react&#39;; import axios from &#39;axios&#39;; import { useRouter } from &#39;next/router&#39;; import { useEffect, useState } from &#39;react&#39;; import { Document, Page } from &#39;react-pdf&#39;; import { pdfjs } from &#39;react-pdf&#39;; import PdfPageNumber from &#39;./PdfPageNumber&#39;; type Props = { isOpenPreview: boolean; onClosePreview: () =&gt; void; fileId: string; fileUrl: string; onOpenProcessing: () =&gt; void; onCloseProcessing: () =&gt; void; }; export default function FilePreviewModal({ isOpenPreview, onClosePreview, fileId, fileUrl, onOpenProcessing, onCloseProcessing, }: Props) { const { getToken } = useAuth(); const router = useRouter(); const toast = useToast(); const [numPagesPDF, setNumPagesPDF] = useState&lt;number | null&gt;(null); const [pageNumberPDF, setPageNumberPDF] = useState(1); const fileType = getFileExtensionFromPath(fileUrl); useEffect(() =&gt; { if (!isOpenPreview) { setNumPagesPDF(null); setPageNumberPDF(1); } }, [isOpenPreview]); async function handleRunRecaption() { onClosePreview(); onOpenProcessing(); try { await apiInstance(getToken()).get(`api/v1/predict/${fileId}`); await router.push({ pathname: `/recognizer-result/${fileId}`, }); } catch (error) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { toast({ description: error.response?.data.error, status: &#39;error&#39;, isClosable: true, position: &#39;top&#39;, }); } } finally { onCloseProcessing(); } } function onDocumentLoadSuccess({ numPages }: { numPages: number }) { setNumPagesPDF(numPages); } function isImage(fileType: string) { return fileType === &#39;jpg&#39; || fileType === &#39;jpeg&#39; || fileType === &#39;png&#39;; } pdfjs.GlobalWorkerOptions.workerSrc = `//unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.js`; return ( &lt;Modal isOpen={isOpenPreview} onClose={onClosePreview} size={&#39;xl&#39;}&gt; &lt;ModalOverlay /&gt; &lt;ModalContent bgColor={&#39;#F8F8F8&#39;} py={6} px={10} minW={&#39;max-content&#39;}&gt; &lt;ModalHeader p={0}&gt;File Preview&lt;/ModalHeader&gt; {fileType === &#39;pdf&#39; &amp;&amp; ( &lt;PdfPageNumber numPagesPDF={numPagesPDF} pageNumberPDF={pageNumberPDF} setPageNumberPDF={setPageNumberPDF} /&gt; )} &lt;ModalCloseButton /&gt; &lt;ModalBody mt={4} p={0}&gt; {fileType === &#39;pdf&#39; &amp;&amp; ( &lt;Document file={trimPath(fileUrl)} onLoadSuccess={onDocumentLoadSuccess} &gt; &lt;Page pageNumber={pageNumberPDF} renderTextLayer={false} renderAnnotationLayer={false} /&gt; &lt;/Document&gt; )} {isImage(fileType) &amp;&amp; ( &lt;Image minW={&#39;full&#39;} src={fileUrl ? trimPath(fileUrl) : &#39;&#39;} alt=&quot;image-preview&quot; /&gt; )} &lt;/ModalBody&gt; &lt;ModalFooter mt={4} p={0} justifyContent={&#39;center&#39;}&gt; &lt;Button w={&#39;250px&#39;} variant={&#39;solid-primary&#39;} fontSize={20} fontWeight={300} onClick={handleRunRecaption} &gt; Run Recaption &lt;/Button&gt; &lt;/ModalFooter&gt; &lt;/ModalContent&gt; &lt;/Modal&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/PdfPageNumber.tsx",

      "name": "PdfPageNumber.tsx",

      "content":

        "import { HStack, Button, Text } from &#39;@chakra-ui/react&#39;; type PdfPageNumberProps = { numPagesPDF: number | null; pageNumberPDF: number; setPageNumberPDF: React.Dispatch&lt;React.SetStateAction&lt;number&gt;&gt;; }; export default function PdfPageNumber({ numPagesPDF, pageNumberPDF, setPageNumberPDF, }: PdfPageNumberProps) { return ( &lt;&gt; {numPagesPDF !== null &amp;&amp; ( &lt;HStack alignSelf={&#39;center&#39;}&gt; &lt;Button isDisabled={pageNumberPDF === 1} variant={&#39;outline-secondary&#39;} size={&#39;xs&#39;} onClick={() =&gt; { if (numPagesPDF !== null) { const nextPage = pageNumberPDF - 1; setPageNumberPDF(nextPage); } }} &gt; {&#39;&lt; prev&#39;} &lt;/Button&gt; &lt;Text mx={1}&gt; page {pageNumberPDF} of {numPagesPDF} &lt;/Text&gt; &lt;Button isDisabled={pageNumberPDF === numPagesPDF} variant={&#39;outline-secondary&#39;} size={&#39;xs&#39;} onClick={() =&gt; { if (numPagesPDF !== null) { const nextPage = pageNumberPDF + 1; setPageNumberPDF(nextPage); } }} &gt; {&#39;next &gt;&#39;} &lt;/Button&gt; &lt;/HStack&gt; )} &lt;/&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/FileHistoryTable.tsx",

      "name": "FileHistoryTable.tsx",

      "content":

        "import { ColumnFiltersState, createColumnHelper, flexRender, getCoreRowModel, getFilteredRowModel, getPaginationRowModel, useReactTable, } from &#39;@tanstack/react-table&#39;; import { HTMLProps, useEffect, useRef, useState } from &#39;react&#39;; import { Button, Flex, Table, Tbody, Td, Text, Th, Thead, Tr, Image, useDisclosure, HStack, Tab, TabList, TabPanels, Tabs, useToast, } from &#39;@chakra-ui/react&#39;; import { getFileExtensionFromPath, parseFileName } from &#39;@/lib/file&#39;; import { filesize } from &#39;filesize&#39;; import { format } from &#39;date-format-parse&#39;; import Link from &#39;next/link&#39;; import DeleteFileModal from &#39;./DeleteFileModal&#39;; import DeleteAllFileModal from &#39;./DeleteAllFileModel&#39;; import React from &#39;react&#39;; import type { Row } from &#39;@tanstack/react-table&#39;; import ResultService from &#39;@/services/result&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; import XLSX from &#39;sheetjs-style&#39;; import { saveAs } from &#39;file-saver&#39;; import axios from &#39;axios&#39;; import { documentKeyOrder } from &#39;./recognizer-result/ResultTable&#39;; export type FileHistory = { fileId: string; filename: string; type: string; size: number; timestamp: string; resultId: string; }; type FileHistoryTableProps = { dataTable: TableResult[]; }; export function getFileNameFromPath(filePath: string) { // given &#39;/uploads/name&quot; return name // given &#39;\\uploads\\name&quot; return name let pathSeparator = &#39;/&#39;; if (filePath.includes(&#39;\\&#39;)) { pathSeparator = &#39;\\&#39;; } const pathParts = filePath.split(pathSeparator); const name = pathParts[pathParts.length - 1]; return name; } export function getFileNameFromUuid(uuid: string) { // given &#39;name-uuid&#39; return &#39;name&#39; const nameIndex = uuid.indexOf(&#39;-&#39;); if (nameIndex !== -1) { return uuid.substring(0, nameIndex); } else { return uuid; } } const documentType = [ { key: &#39;all&#39;, value: &#39;All&#39; }, { key: &#39;ktp&#39;, value: &#39;KTP&#39; }, { key: &#39;npwp&#39;, value: &#39;NPWP&#39; }, { key: &#39;invoice&#39;, value: &#39;Invoice&#39; }, { key: &#39;pajak&#39;, value: &#39;Faktur Pajak&#39; }, { key: &#39;passport&#39;, value: &#39;Passport&#39; }, ]; const fileType = &#39;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8&#39;; const fileExtension = &#39;.xlsx&#39;; export default function FileHistoryTable({ dataTable }: FileHistoryTableProps) { const { getToken } = useAuth(); const toast = useToast(); const [rowSelection, setRowSelection] = useState({}); const [columnFilters, setColumnFilters] = useState&lt;ColumnFiltersState&gt;([]); const [columnVisibility, setColumnVisibility] = useState({}); const { isOpen: isOpenDelete, onOpen: onOpenDelete, onClose: onCloseDelete, } = useDisclosure(); const { isOpen: isOpenDeleteAll, onOpen: onOpenDeleteAll, onClose: onCloseDeleteAll, } = useDisclosure(); useEffect(() =&gt; { table.getColumn(&#39;select&#39;)?.toggleVisibility(isShowCheckbox()); }, [columnFilters]); const [selectedFile, setSelectedFile] = useState&lt;FileHistory&gt;( {} as FileHistory ); const columnHelper = createColumnHelper&lt;FileHistory&gt;(); const columns = [ columnHelper.display({ id: &#39;select&#39;, header: ({ table, }: { table: import(&#39;@tanstack/table-core&#39;).Table&lt;FileHistory&gt;; }) =&gt; ( &lt;IndeterminateCheckbox {...{ checked: table.getIsAllRowsSelected(), indeterminate: table.getIsSomeRowsSelected(), onChange: table.getToggleAllRowsSelectedHandler(), }} /&gt; ), cell: ({ row }: { row: Row&lt;FileHistory&gt; }) =&gt; ( &lt;IndeterminateCheckbox {...{ checked: row.getIsSelected(), disabled: !row.getCanSelect(), indeterminate: row.getIsSomeSelected(), onChange: row.getToggleSelectedHandler(), }} /&gt; ), }), columnHelper.accessor(&#39;filename&#39;, { header: &#39;File Name&#39;, cell: (info) =&gt; ( &lt;Flex align={&#39;center&#39;}&gt; {getFileExtensionFromPath(info.getValue()) === &#39;pdf&#39; ? ( &lt;Image width={&#39;24px&#39;} height={&#39;24px&#39;} src={&#39;./icon/pdf.svg&#39;} alt=&quot;pdf&quot; /&gt; ) : ( &lt;Image width={&#39;24px&#39;} height={&#39;24px&#39;} src={&#39;./icon/image.svg&#39;} alt=&quot;image&quot; /&gt; )} &lt;Text ml={4}&gt;{parseFileName(info.getValue())}&lt;/Text&gt; &lt;/Flex&gt; ), }), columnHelper.accessor(&#39;type&#39;, { header: &#39;Type&#39;, enableColumnFilter: true, }), columnHelper.accessor(&#39;size&#39;, { header: &#39;Size&#39;, cell: (info) =&gt; filesize(info.getValue(), { base: 2, standard: &#39;jedec&#39;, round: 0 }), }), columnHelper.accessor(&#39;timestamp&#39;, { header: &#39;Time Stamp&#39;, cell: (info) =&gt; format(new Date(info.getValue()), &#39;DD/MM/YYYY HH:mm&#39;), }), columnHelper.display({ header: &#39;Actions&#39;, cell: (info) =&gt; ( &lt;HStack&gt; &lt;Link href={`/recognizer-result/${info.row.original.fileId}`} target=&quot;_blank&quot; passHref &gt; &lt;Button variant={&#39;outline-primary&#39;} borderRadius={4} size={&#39;sm&#39;}&gt; See Result &lt;/Button&gt; &lt;/Link&gt; &lt;Button variant={&#39;outline-red&#39;} borderRadius={4} size={&#39;sm&#39;} onClick={() =&gt; handleDelete(info.row.original)} &gt; Delete &lt;/Button&gt; &lt;/HStack&gt; ), }), ]; const table = useReactTable({ data: parseDataTable(dataTable), columns, autoResetPageIndex: false, state: { columnFilters, rowSelection, columnVisibility, }, enableRowSelection: true, onRowSelectionChange: setRowSelection, onColumnFiltersChange: setColumnFilters, onColumnVisibilityChange: setColumnVisibility, getCoreRowModel: getCoreRowModel(), getFilteredRowModel: getFilteredRowModel(), getPaginationRowModel: getPaginationRowModel(), }); useEffect(() =&gt; { table.setPageSize(10); }, [table]); // eslint-disable-next-line function exportToExcel(excelData: any) { // eslint-disable-next-line const header = Object.keys(excelData[0]); const wscolsConfig = []; for (let i = 0; i &lt; header.length; i++) { wscolsConfig.push({ wch: header[i].length + 10 }); } // eslint-disable-next-line const sheet = XLSX.utils.json_to_sheet(excelData); const ws = { Sheets: { data: sheet }, SheetNames: [&#39;data&#39;], }; sheet[&#39;!cols&#39;] = wscolsConfig; // eslint-disable-next-line const excelBuffer = XLSX.write(ws, { bookType: &#39;xlsx&#39;, type: &#39;array&#39; }); const data = new Blob([excelBuffer], { type: fileType }); const fileName = prompt(&#39;Enter file name: &#39;); if (fileName) { saveAs(data, fileName + fileExtension); } } function sortKey(key_value_pairs: Record&lt;string, string&gt;[]) { let keyOrder: string[]; const currentDocumentType = columnFilters[0].value; if (currentDocumentType === &#39;ktp&#39;) { keyOrder = documentKeyOrder.ktp; } else if (currentDocumentType === &#39;npwp&#39;) { keyOrder = documentKeyOrder.npwp; } else if (currentDocumentType === &#39;passport&#39;) { keyOrder = documentKeyOrder.passport; } else if (currentDocumentType === &#39;pajak&#39;) { keyOrder = documentKeyOrder.pajak; } else if (currentDocumentType === &#39;invoice&#39;) { keyOrder = documentKeyOrder.invoice; } return key_value_pairs.map((item) =&gt; { const sorted: Record&lt;string, string&gt; = {}; sorted[&#39;file_name&#39;] = item[&#39;file_name&#39;]; sorted[&#39;created_at&#39;] = item[&#39;created_at&#39;]; keyOrder.forEach((key) =&gt; { if (Object.prototype.hasOwnProperty.call(item, key)) { sorted[key] = item[key]; } }); for (const key in item) { // if sorted data doesnt contain key in input key (filename, etc) if (!Object.prototype.hasOwnProperty.call(sorted, key)) { sorted[key] = item[key]; } } return sorted; }); } async function handleExportDocument( token: string, selectedRowId: string[], rowModel: { rows: Array&lt;Row&lt;FileHistory&gt;&gt;; } ) { const selectedResultId: string[] = []; rowModel.rows.map((row) =&gt; { selectedResultId.push(row.original.resultId); }); try { const res = await ResultService.exportResult({ token, documentType: columnFilters[0].value as string, resultIds: selectedResultId, }); exportToExcel(sortKey(res.data.rows)); } catch (error: unknown) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { toast({ description: error.response?.data.error, status: &#39;error&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); } } } function parseDataTable(dataTable: TableResult[]): FileHistory[] { const result: FileHistory[] = []; if (dataTable) { dataTable.forEach((data) =&gt; { result.push({ fileId: data.file.id, filename: data.file.filePath, resultId: data.id, type: data.file.fileType, size: data.file.fileSize, timestamp: data.createdAt, }); }); } return result; } function isShowCheckbox() { if (columnFilters.length !== 0) { return true; } else { if (columns.length &gt; 5) { return false; } else { return true; } } } function handleDelete(file: FileHistory) { setSelectedFile(file); onOpenDelete(); } function handleDeleteAll() { onOpenDeleteAll(); } function getExportText() { if (columnFilters.length &gt; 0) { return `Export ${Object.keys(rowSelection).length} Selected ${ columnFilters[0].value as number }`; } else { return &#39;Select Document Type to Export&#39;; } } return ( &lt;&gt; &lt;DeleteFileModal isOpen={isOpenDelete} onClose={onCloseDelete} file={selectedFile} /&gt; &lt;DeleteAllFileModal isOpen={isOpenDeleteAll} onClose={onCloseDeleteAll} /&gt; &lt;Flex flexDir={&#39;column&#39;} w=&quot;full&quot;&gt; &lt;Text fontSize={24} fontWeight={500} mt={&#39;104px&#39;}&gt; File History &lt;/Text&gt; &lt;Flex mt={4}&gt; &lt;Flex border={&#39;1px solid gray.400&#39;} mr={2}&gt; &lt;select value={table.getState().pagination.pageSize} onChange={(e) =&gt; { table.setPageSize(Number(e.target.value)); }} style={{ border: &#39;1px solid gray&#39;, borderRadius: &#39;4px&#39; }} &gt; {[5, 10, 15, 20, 25].map((pageSize) =&gt; ( &lt;option key={pageSize} value={pageSize}&gt; {pageSize} / page &lt;/option&gt; ))} &lt;/select&gt; &lt;/Flex&gt; &lt;Button variant={&#39;outline-red&#39;} borderRadius={4} size={&#39;sm&#39;} bg={&#39;white&#39;} onClick={handleDeleteAll} &gt; Delete all result &lt;/Button&gt; &lt;Button variant={&#39;outline-primary&#39;} ml={2} borderRadius={4} size={&#39;sm&#39;} bg={&#39;white&#39;} isDisabled={ Object.keys(rowSelection).length === 0 || columnFilters.length === 0 } onClick={() =&gt; handleExportDocument( getToken(), Object.keys(rowSelection), table.getFilteredSelectedRowModel() ) } &gt; {getExportText()} &lt;/Button&gt; &lt;/Flex&gt; &lt;Tabs mt={4}&gt; &lt;TabList&gt; {documentType.map((item) =&gt; ( &lt;Tab onClick={() =&gt; { table.setPageIndex(0); setRowSelection({}); if (item.key === &#39;all&#39;) { setColumnFilters([]); } else { setColumnFilters([{ id: &#39;type&#39;, value: item.key }]); } }} bgColor={&#39;white&#39;} key={item.key} &gt; {item.value} &lt;/Tab&gt; ))} &lt;/TabList&gt; &lt;TabPanels&gt; &lt;Table&gt; &lt;Thead bg={&#39;gray.100&#39;}&gt; {table.getHeaderGroups().map((headerGroup) =&gt; ( &lt;Tr key={headerGroup.id}&gt; {headerGroup.headers.map((header) =&gt; ( &lt;Th key={header.id} color={&#39;black&#39;}&gt; {header.isPlaceholder ? null : flexRender( header.column.columnDef.header, header.getContext() )} &lt;/Th&gt; ))} &lt;/Tr&gt; ))} &lt;/Thead&gt; &lt;Tbody bg={&#39;white&#39;}&gt; {table.getRowModel().rows.map((row) =&gt; ( &lt;Tr key={row.id}&gt; {row.getVisibleCells().map((cell) =&gt; ( &lt;Td key={cell.id}&gt; {flexRender( cell.column.columnDef.cell, cell.getContext() )} &lt;/Td&gt; ))} &lt;/Tr&gt; ))} &lt;/Tbody&gt; &lt;/Table&gt; &lt;/TabPanels&gt; &lt;/Tabs&gt; &lt;Flex align={&#39;center&#39;} mt={4}&gt; &lt;Text mr={2}&gt; Total{&#39; &#39;} {table.getFilteredRowModel().rows ? table.getFilteredRowModel().rows.length : 0}{&#39; &#39;} items &lt;/Text&gt; &lt;Flex&gt; &lt;Button mr={2} w={&#39;27px&#39;} h={&#39;27px&#39;} color={&#39;green.400&#39;} bg={&#39;white&#39;} border={&#39;1px solid&#39;} borderColor={&#39;gray.400&#39;} borderRadius={0} _hover={{ bg: &#39;green.400&#39;, color: &#39;white&#39;, }} size={&#39;sm&#39;} onClick={() =&gt; table.setPageIndex(0)} isDisabled={!table.getCanPreviousPage()} &gt; {&#39;&lt;&lt;&#39;} &lt;/Button&gt; &lt;Button mr={2} w={&#39;27px&#39;} h={&#39;27px&#39;} color={&#39;green.400&#39;} bg={&#39;white&#39;} border={&#39;1px solid&#39;} borderColor={&#39;gray.400&#39;} borderRadius={0} _hover={{ bg: &#39;green.400&#39;, color: &#39;white&#39;, }} size={&#39;sm&#39;} onClick={() =&gt; table.previousPage()} isDisabled={!table.getCanPreviousPage()} &gt; {&#39;&lt;&#39;} &lt;/Button&gt; &lt;Button mr={2} w={&#39;27px&#39;} h={&#39;27px&#39;} color={&#39;green.400&#39;} bg={&#39;white&#39;} border={&#39;1px solid&#39;} borderColor={&#39;gray.400&#39;} borderRadius={0} _hover={{ bg: &#39;green.400&#39;, color: &#39;white&#39;, }} size={&#39;sm&#39;} onClick={() =&gt; table.nextPage()} isDisabled={!table.getCanNextPage()} &gt; {&#39;&gt;&#39;} &lt;/Button&gt; &lt;Button mr={2} w={&#39;27px&#39;} h={&#39;27px&#39;} color={&#39;green.400&#39;} bg={&#39;white&#39;} border={&#39;1px solid&#39;} borderColor={&#39;gray.400&#39;} borderRadius={0} _hover={{ bg: &#39;green.400&#39;, color: &#39;white&#39;, }} size={&#39;sm&#39;} onClick={() =&gt; table.setPageIndex(table.getPageCount() - 1)} isDisabled={!table.getCanNextPage()} &gt; {&#39;&gt;&gt;&#39;} &lt;/Button&gt; &lt;/Flex&gt; &lt;Flex&gt; &lt;Text mr={2}&gt; Page{&#39; &#39;} {table.getFilteredRowModel().rows.length &gt; 0 ? table.getState().pagination.pageIndex + 1 : 0}{&#39; &#39;} of {table.getPageCount()} &lt;/Text&gt; &lt;Text mr={2}&gt;| Go to&lt;/Text&gt; &lt;input style={{ width: &#39;40px&#39;, paddingLeft: &#39;4px&#39;, border: &#39;1px solid gray&#39;, }} type=&quot;number&quot; defaultValue={table.getState().pagination.pageIndex + 1} onChange={(e) =&gt; { const page = e.target.value ? Number(e.target.value) - 1 : 0; table.setPageIndex(page); }} /&gt; &lt;/Flex&gt; &lt;/Flex&gt; &lt;/Flex&gt; &lt;/&gt; ); } function IndeterminateCheckbox({ indeterminate, ...rest }: { indeterminate?: boolean } &amp; HTMLProps&lt;HTMLInputElement&gt;) { const ref = useRef&lt;HTMLInputElement&gt;(null!); useEffect(() =&gt; { if (typeof indeterminate === &#39;boolean&#39;) { ref.current.indeterminate = !rest.checked &amp;&amp; indeterminate; } }, [ref, indeterminate]); return &lt;input type=&quot;checkbox&quot; ref={ref} {...rest} /&gt;; } "

    },

    {

      "path": "recaption-application-main/components/ChangeUserPasswordModal.tsx",

      "name": "ChangeUserPasswordModal.tsx",

      "content":

        "import { Modal, ModalOverlay, ModalContent, ModalHeader, ModalCloseButton, ModalBody, ModalFooter, Button, FormControl, FormErrorMessage, FormLabel, Input, useToast, } from &#39;@chakra-ui/react&#39;; import { SubmitHandler, useForm } from &#39;react-hook-form&#39;; import userService from &#39;@/services/user&#39;; import loginService from &#39;@/services/login&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; import axios from &#39;axios&#39;; import { useState } from &#39;react&#39;; type ChangeUserPasswordModalProps = { isOpen: boolean; onClose: () =&gt; void; userId: string; email: string; }; type ChangePasswordFormInputs = { currentPassword: string; }; type NewPasswordFormInputs = { password: string; confirmPassword: string; }; export default function ChangeUserPasswordModal({ isOpen, onClose, userId, email, }: ChangeUserPasswordModalProps) { const [step, setStep] = useState(1); const toast = useToast(); const { getToken } = useAuth(); const { register, handleSubmit, formState: { errors: errors }, } = useForm&lt;ChangePasswordFormInputs&gt;(); const { register: registerNewPassword, handleSubmit: handleSubmitNewPassword, formState: { errors: errorsNewPassword }, watch: watchNewPassword, } = useForm&lt;NewPasswordFormInputs&gt;(); const onSubmit: SubmitHandler&lt;ChangePasswordFormInputs&gt; = async (data) =&gt; { try { const payload = { email: email, password: data.currentPassword, }; await loginService.login(payload); setStep(2); } catch (error: unknown) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { let errorMessage = &#39;&#39;; if (error.response?.data.error === &#39;Invalid email or password&#39;) { errorMessage = &#39;Invalid password&#39;; } toast({ description: errorMessage, status: &#39;error&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); } } }; const onSubmitNewPassword: SubmitHandler&lt;NewPasswordFormInputs&gt; = async ( data ) =&gt; { try { const payload = { password: data.password, confirmPassword: data.confirmPassword, }; const res = await userService.resetPassword(getToken(), payload, userId); toast({ description: res.message, status: &#39;success&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); onClose(); } catch (error: unknown) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { toast({ description: error.response?.data.error, status: &#39;error&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); } } }; const stepOne = ( &lt;&gt; &lt;ModalHeader&gt;Input your current password&lt;/ModalHeader&gt; &lt;ModalCloseButton /&gt; &lt;form onSubmit={handleSubmit(onSubmit)}&gt; &lt;ModalBody&gt; &lt;FormControl isInvalid={Boolean(errors.currentPassword)}&gt; &lt;FormLabel htmlFor=&quot;current-password&quot;&gt;Current password&lt;/FormLabel&gt; &lt;Input id=&quot;current-password&quot; type=&quot;password&quot; {...register(&#39;currentPassword&#39;, { required: &#39;Password is required&#39;, })} /&gt; &lt;FormErrorMessage&gt; {errors.currentPassword &amp;&amp; errors.currentPassword.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;/ModalBody&gt; &lt;ModalFooter&gt; &lt;Button variant=&quot;outline-red&quot; mr={3} onClick={onClose}&gt; Cancel &lt;/Button&gt; &lt;Button type=&quot;submit&quot; variant=&quot;outline-primary&quot;&gt; Next &lt;/Button&gt; &lt;/ModalFooter&gt; &lt;/form&gt; &lt;/&gt; ); const stepTwo = ( &lt;&gt; &lt;ModalHeader&gt;Input your new password&lt;/ModalHeader&gt; &lt;ModalCloseButton /&gt; &lt;form onSubmit={handleSubmitNewPassword(onSubmitNewPassword)}&gt; &lt;ModalBody&gt; &lt;FormControl isInvalid={Boolean(errorsNewPassword.password)}&gt; &lt;FormLabel htmlFor=&quot;password&quot;&gt;Password&lt;/FormLabel&gt; &lt;Input id=&quot;password&quot; type=&quot;password&quot; {...registerNewPassword(&#39;password&#39;, { required: &#39;Password is required&#39;, })} /&gt; &lt;FormErrorMessage&gt; {errorsNewPassword.password &amp;&amp; errorsNewPassword.password.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;FormControl isInvalid={Boolean(errorsNewPassword.confirmPassword)}&gt; &lt;FormLabel htmlFor=&quot;confirmPassword&quot;&gt;Confirm password&lt;/FormLabel&gt; &lt;Input id=&quot;confirmPassword&quot; type=&quot;password&quot; {...registerNewPassword(&#39;confirmPassword&#39;, { required: &#39;Confirm password is required&#39;, validate: (val: string) =&gt; { if (watchNewPassword(&#39;password&#39;) !== val) { return &#39;Your passwords do not match&#39;; } }, })} /&gt; &lt;FormErrorMessage&gt; {errorsNewPassword.confirmPassword &amp;&amp; errorsNewPassword.confirmPassword.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;/ModalBody&gt; &lt;ModalFooter&gt; &lt;Button variant=&quot;outline-red&quot; mr={3} onClick={onClose}&gt; Cancel &lt;/Button&gt; &lt;Button type=&quot;submit&quot; variant=&quot;outline-primary&quot;&gt; Save &lt;/Button&gt; &lt;/ModalFooter&gt; &lt;/form&gt; &lt;/&gt; ); return ( &lt;Modal isOpen={isOpen} onClose={onClose}&gt; &lt;ModalOverlay /&gt; &lt;ModalContent&gt; {step === 1 &amp;&amp; stepOne} {step === 2 &amp;&amp; stepTwo} &lt;/ModalContent&gt; &lt;/Modal&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/DeleteFileModal.tsx",

      "name": "DeleteFileModal.tsx",

      "content":

        "import { useAuth } from &#39;@/contexts/AuthContext&#39;; import { Button, Modal, ModalOverlay, ModalContent, ModalHeader, ModalCloseButton, ModalBody, ModalFooter, Text, } from &#39;@chakra-ui/react&#39;; import { FileHistory } from &#39;./FileHistoryTable&#39;; import { useMutation, useQueryClient } from &#39;react-query&#39;; import resultService from &#39;@/services/result&#39;; import { getFileNameFromPath, getFileNameFromUuid } from &#39;@/lib/file&#39;; type DeleteFileModalProps = { isOpen: boolean; onClose: () =&gt; void; file: FileHistory; }; export default function DeleteFileModal({ isOpen, onClose, file, }: DeleteFileModalProps) { const { getToken } = useAuth(); const queryClient = useQueryClient(); const deleteMutation = useMutation(resultService.deleteResult); function handleDelete(resultId: string) { deleteMutation.mutate( { token: getToken(), resultId }, { onSuccess: async () =&gt; { await queryClient.invalidateQueries(&#39;results&#39;); }, } ); onClose(); } return ( &lt;&gt; &lt;Modal isCentered isOpen={isOpen} onClose={onClose}&gt; &lt;ModalOverlay /&gt; &lt;ModalContent&gt; &lt;ModalHeader&gt;Confirm Delete&lt;/ModalHeader&gt; &lt;ModalCloseButton /&gt; &lt;ModalBody&gt; &lt;Text&gt; Are you sure you want to delete{&#39; &#39;} &lt;Text as={&#39;span&#39;} fontWeight={500}&gt; {file?.filename !== undefined ? getFileNameFromPath(getFileNameFromUuid(file.filename)) : &#39;&#39;} &lt;/Text&gt; ? &lt;/Text&gt; &lt;/ModalBody&gt; &lt;ModalFooter&gt; &lt;Button variant={&#39;outline-secondary&#39;} mr={3} onClick={onClose}&gt; Cancel &lt;/Button&gt; &lt;Button colorScheme=&quot;red&quot; onClick={() =&gt; handleDelete(file.resultId)} &gt; Delete &lt;/Button&gt; &lt;/ModalFooter&gt; &lt;/ModalContent&gt; &lt;/Modal&gt; &lt;/&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/ExportExcel.tsx",

      "name": "ExportExcel.tsx",

      "content":

        "import { Button } from &#39;@chakra-ui/react&#39;; import { saveAs } from &#39;file-saver&#39;; import XLSX from &#39;sheetjs-style&#39;; import type { Result } from &#39;@/components/recognizer-result/ResultTable&#39;; import { useFileStore } from &#39;@/stores&#39;; import { getFileNameFromPath, getFileNameFromUuid } from &#39;./FileHistoryTable&#39;; type ExportExcelProps = { excelData: Result[]; }; export function ExportExcel({ excelData }: ExportExcelProps) { const fileUrl = useFileStore((state) =&gt; state.fileUrl); const fileName = getFileNameFromUuid(getFileNameFromPath(fileUrl)); const fileType = &#39;application/vnd.openxmlformats-officedocument.spreadsheetml.sheet;charset=UTF-8&#39;; const fileExtension = &#39;.xlsx&#39;; function exportToExcel() { const header = Object.keys(excelData[0]); const wscolsConfig = []; for (let i = 0; i &lt; header.length; i++) { wscolsConfig.push({ wch: header[i].length + 20 }); } // add % to value of confidence column const modifiedExcelData = excelData; for (let i = 0; i &lt; excelData.length; i++) { modifiedExcelData[i].confidence = `${excelData[i].confidence}%`; } const sheet = XLSX.utils.json_to_sheet(excelData); const ws = { Sheets: { data: sheet }, SheetNames: [&#39;data&#39;], }; sheet[&#39;!cols&#39;] = wscolsConfig; // eslint-disable-next-line const excelBuffer = XLSX.write(ws, { bookType: &#39;xlsx&#39;, type: &#39;array&#39; }); const data = new Blob([excelBuffer], { type: fileType }); // eslint-disable-next-line saveAs(data, fileName + fileExtension); } return ( &lt;Button mt={6} fontWeight={400} borderRadius={&#39;4px&#39;} alignSelf={&#39;center&#39;} variant=&quot;solid-primary&quot; w={&#39;250px&#39;} onClick={exportToExcel} &gt; Export &lt;/Button&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/ProfileForm.tsx",

      "name": "ProfileForm.tsx",

      "content":

        "import { SimpleGrid, FormControl, FormLabel, Input, HStack, Button, Flex, useToast, Select, FormErrorMessage, useDisclosure, } from &#39;@chakra-ui/react&#39;; import { useForm, SubmitHandler, Controller } from &#39;react-hook-form&#39;; import userService from &#39;@/services/user&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; import axios from &#39;axios&#39;; import { useQueryClient } from &#39;react-query&#39;; import ChangeUserPasswordModalForAdmin from &#39;./ChangeUserPasswordModalForAdmin&#39;; import ChangeUserPasswordModal from &#39;./ChangeUserPasswordModal&#39;; export type ProfileFormProps = { user: User; }; type ProfileFormInputs = Omit&lt;User, &#39;id&#39;&gt;; export default function ProfileForm({ user }: ProfileFormProps) { const queryClient = useQueryClient(); const { getToken, getUser } = useAuth(); const signedRole = getUser().role; const toast = useToast(); const { isOpen, onOpen, onClose } = useDisclosure(); const { isOpen: isOpenForUser, onOpen: onOpenForUser, onClose: onCloseForUser, } = useDisclosure(); const { register, handleSubmit, formState: { errors: errors }, reset, control, } = useForm&lt;ProfileFormInputs&gt;({ defaultValues: user }); const onSubmit: SubmitHandler&lt;ProfileFormInputs&gt; = async (data) =&gt; { try { const res = await userService.updateUser(getToken(), user.id, data); toast({ description: res.message, status: &#39;success&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); await queryClient.invalidateQueries({ queryKey: [&#39;user&#39;, user.id] }); } catch (error: unknown) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { toast({ description: error.response?.data.error ?? &#39;&#39;, status: &#39;error&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); } } }; return ( &lt;&gt; &lt;ChangeUserPasswordModal isOpen={isOpenForUser} onClose={onCloseForUser} userId={user.id} email={user.email} /&gt; &lt;ChangeUserPasswordModalForAdmin isOpen={isOpen} onClose={onClose} userId={user.id} /&gt; &lt;form onSubmit={handleSubmit(onSubmit)} style={{ width: &#39;100%&#39; }}&gt; &lt;Flex flexDir={&#39;column&#39;}&gt; &lt;SimpleGrid columns={2} spacing={8}&gt; &lt;FormControl isInvalid={Boolean(errors.username)}&gt; &lt;FormLabel htmlFor=&quot;username&quot;&gt;Username&lt;/FormLabel&gt; &lt;Input id=&quot;username&quot; type=&quot;text&quot; {...register(&#39;username&#39;, { required: &#39;Username is required&#39; })} /&gt; &lt;FormErrorMessage&gt; {errors.username &amp;&amp; errors.username.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;FormControl isInvalid={Boolean(errors.email)}&gt; &lt;FormLabel&gt;Email&lt;/FormLabel&gt; &lt;Input type=&quot;text&quot; {...register(&#39;email&#39;, { disabled: signedRole === &#39;admin&#39; ? false : true, required: &#39;Email is required&#39;, })} /&gt; &lt;FormErrorMessage&gt; {errors.email &amp;&amp; errors.email.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;FormControl isInvalid={Boolean(errors.quota)}&gt; &lt;FormLabel&gt;Quota&lt;/FormLabel&gt; &lt;Input type=&quot;text&quot; {...register(&#39;quota&#39;, { disabled: signedRole === &#39;admin&#39; ? false : true, required: &#39;Quota is required&#39;, })} /&gt; &lt;FormErrorMessage&gt; {errors.quota &amp;&amp; errors.quota.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;FormControl isInvalid={Boolean(errors.limit)}&gt; &lt;FormLabel&gt;Limit&lt;/FormLabel&gt; &lt;Input type=&quot;text&quot; {...register(&#39;limit&#39;, { disabled: signedRole === &#39;admin&#39; ? false : true, required: &#39;Limit is required&#39;, })} /&gt; &lt;FormErrorMessage&gt; {errors.limit &amp;&amp; errors.limit.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;Flex flexDir={&#39;column&#39;}&gt; &lt;FormLabel&gt;Role&lt;/FormLabel&gt; &lt;Controller name=&quot;role&quot; control={control} render={({ field }) =&gt; ( &lt;Select {...field} disabled={signedRole === &#39;admin&#39; ? false : true} &gt; &lt;option value=&quot;admin&quot;&gt;admin&lt;/option&gt; &lt;option value=&quot;user&quot;&gt;user&lt;/option&gt; &lt;/Select&gt; )} /&gt; &lt;/Flex&gt; &lt;/SimpleGrid&gt; &lt;Flex justify={&#39;space-between&#39;}&gt; &lt;Button mt={6} onClick={signedRole === &#39;admin&#39; ? onOpen : onOpenForUser} alignSelf={&#39;flex-start&#39;} variant={&#39;outline-primary&#39;} &gt; Change password &lt;/Button&gt; &lt;HStack mt={4} spacing={4} alignSelf={&#39;flex-end&#39;}&gt; &lt;Button variant=&quot;outline-red&quot; onClick={() =&gt; { reset(user); }} &gt; Reset &lt;/Button&gt; &lt;Button variant=&quot;outline-primary&quot; type=&quot;submit&quot;&gt; Save &lt;/Button&gt; &lt;/HStack&gt; &lt;/Flex&gt; &lt;/Flex&gt; &lt;/form&gt; &lt;/&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/Footer.tsx",

      "name": "Footer.tsx",

      "content":

        "import { Divider, Flex, Text } from &#39;@chakra-ui/react&#39;; const version = process.env.NEXT_PUBLIC_APP_VERSION; export default function Footer() { return ( &lt;&gt; &lt;Divider /&gt; &lt;Flex flexDir={&#39;column&#39;} align={&#39;center&#39;} py={4}&gt; &lt;Text&gt;{version} Â© lapis.ai - 2023&lt;/Text&gt; &lt;/Flex&gt; &lt;/&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/ChangeUserPasswordModalForAdmin.tsx",

      "name": "ChangeUserPasswordModalForAdmin.tsx",

      "content":

        "import { Modal, ModalOverlay, ModalContent, ModalHeader, ModalCloseButton, ModalBody, ModalFooter, Button, FormControl, FormErrorMessage, FormLabel, Input, useToast, } from &#39;@chakra-ui/react&#39;; import { SubmitHandler, useForm } from &#39;react-hook-form&#39;; import userService from &#39;@/services/user&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; import axios from &#39;axios&#39;; type ChangeUserPasswordModalProps = { isOpen: boolean; onClose: () =&gt; void; userId: string; }; type ChangePasswordFormInputs = { newPassword: string; }; export default function ChangeUserPasswordModalForAdmin({ isOpen, onClose, userId, }: ChangeUserPasswordModalProps) { const toast = useToast(); const { register, handleSubmit, formState: { errors: errors }, } = useForm&lt;ChangePasswordFormInputs&gt;(); const { getToken } = useAuth(); const onSubmit: SubmitHandler&lt;ChangePasswordFormInputs&gt; = async (data) =&gt; { try { const payload = { password: data.newPassword, userId: userId, }; const res = await userService.updateUserPasswordByAdmin( getToken(), userId, payload ); toast({ description: res.message, status: &#39;success&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); onClose(); } catch (error: unknown) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { toast({ description: error.response?.data.error ?? &#39;&#39;, status: &#39;error&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); } } }; return ( &lt;Modal isOpen={isOpen} onClose={onClose}&gt; &lt;ModalOverlay /&gt; &lt;ModalContent&gt; &lt;ModalHeader&gt;Input new user password&lt;/ModalHeader&gt; &lt;ModalCloseButton /&gt; &lt;form onSubmit={handleSubmit(onSubmit)}&gt; &lt;ModalBody&gt; &lt;FormControl isInvalid={Boolean(errors.newPassword)}&gt; &lt;FormLabel htmlFor=&quot;new-password&quot;&gt;New password&lt;/FormLabel&gt; &lt;Input id=&quot;new-password&quot; type=&quot;password&quot; {...register(&#39;newPassword&#39;, { required: &#39;Password is required&#39;, minLength: { value: 8, message: &#39;Password should be at least 8 characters&#39;, }, })} /&gt; &lt;FormErrorMessage&gt; {errors.newPassword &amp;&amp; errors.newPassword.message} &lt;/FormErrorMessage&gt; &lt;/FormControl&gt; &lt;/ModalBody&gt; &lt;ModalFooter&gt; &lt;Button variant=&quot;outline-red&quot; mr={3} onClick={onClose}&gt; Cancel &lt;/Button&gt; &lt;Button type=&quot;submit&quot; variant=&quot;outline-primary&quot;&gt; Save &lt;/Button&gt; &lt;/ModalFooter&gt; &lt;/form&gt; &lt;/ModalContent&gt; &lt;/Modal&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/PageWrapper.tsx",

      "name": "PageWrapper.tsx",

      "content":

        "import { Flex, Container, Divider, Text } from &#39;@chakra-ui/react&#39;; type PageWrapperProps = { title: string; children: React.ReactNode; }; export default function PageWrapper({ title, children }: PageWrapperProps) { return ( &lt;Flex bg={&#39;#DCF3E1&#39;} w=&quot;full&quot; minH={&#39;calc(100vh - 133px)&#39;} px={8}&gt; &lt;Container maxW=&quot;container.lg&quot; bg={&#39;white&#39;} my={12} px={8} pt={6} pb={8} borderRadius={&#39;lg&#39;} &gt; &lt;Text mb={4} fontSize={&#39;2xl&#39;} alignSelf={&#39;flex-start&#39;}&gt; {title} &lt;/Text&gt; &lt;Divider mb={4} /&gt; {children} &lt;/Container&gt; &lt;/Flex&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/DocumentCard.tsx",

      "name": "DocumentCard.tsx",

      "content":

        "import { Button, Flex, Text, useDisclosure, Image, useToast, } from &#39;@chakra-ui/react&#39;; import { useState } from &#39;react&#39;; import uploadService from &#39;../services/upload&#39;; import FilePreviewModal from &#39;./FilePreviewModal&#39;; import ProcessingRecaptionModal from &#39;./ProcessingRecaptionModal&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; import axios from &#39;axios&#39;; import LoadingBar from &#39;react-top-loading-bar&#39;; type Props = { icon: string; title: string; type: string; }; export default function DocumentCard({ icon, title, type }: Props) { const { isOpen: isOpenPreview, onOpen: onOpenPreview, onClose: onClosePreview, } = useDisclosure(); const { isOpen: isOpenProcessing, onOpen: onOpenProcessing, onClose: onCloseProcessing, } = useDisclosure(); const { getToken } = useAuth(); const toast = useToast(); const [fileUrl, setFileUrl] = useState(&#39;&#39;); const [fileId, setFileId] = useState(&#39;&#39;); const [progress, setProgress] = useState(0); async function handleFileChange(e: React.ChangeEvent&lt;HTMLInputElement&gt;) { if (e.target.files) { const file = e.target.files[0]; const body = new FormData(); body.append(&#39;media&#39;, file); body.append(&#39;type&#39;, type); try { const data = await uploadService.upload(body, getToken(), setProgress); setFileId(data.id); setFileUrl(data.filePath); e.target.value = &#39;&#39;; } catch (error) { if (axios.isAxiosError&lt;{ error: string }&gt;(error)) { toast({ description: error.response?.data.error, status: &#39;error&#39;, isClosable: true, position: &#39;top&#39;, duration: 5000, }); } } } } return ( &lt;Flex flexDir={&#39;column&#39;} maxW={&#39;416px&#39;} bgColor={&#39;white&#39;} align={&#39;center&#39;} p={6} borderRadius={&#39;12px&#39;} justifySelf={&#39;center&#39;} &gt; &lt;LoadingBar color=&quot;#0db52b&quot; progress={progress} onLoaderFinished={() =&gt; { setProgress(0); onOpenPreview(); }} shadow={false} waitingTime={0} height={4} /&gt; &lt;FilePreviewModal isOpenPreview={isOpenPreview} onClosePreview={onClosePreview} fileId={fileId} fileUrl={fileUrl} onOpenProcessing={onOpenProcessing} onCloseProcessing={onCloseProcessing} /&gt; &lt;ProcessingRecaptionModal isOpenProcessing={isOpenProcessing} onCloseProcessing={onCloseProcessing} /&gt; &lt;Image width={120} height={120} src={icon} alt={title} /&gt; &lt;Text mt={11} fontSize={30} color={&#39;green.400&#39;}&gt; {title} &lt;/Text&gt; &lt;&gt; &lt;Button mt={6} w=&quot;250px&quot; variant={&#39;solid-primary&#39;} borderRadius={&#39;4.8px&#39;} color={&#39;white&#39;} fontWeight={&#39;normal&#39;} p={0} &gt; &lt;label style={{ width: &#39;100%&#39;, padding: 12 }} htmlFor={type}&gt; Upload File &lt;/label&gt; &lt;input id={type} type=&quot;file&quot; hidden onChange={handleFileChange} accept=&quot;.pdf,.jpg,.jpeg&quot; /&gt; &lt;/Button&gt; &lt;Text fontSize={&#39;sm&#39;} mt={2} color={&#39;gray.600&#39;}&gt; Supported format: pdf/jpg &lt;/Text&gt; &lt;/&gt; &lt;/Flex&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/Layout.tsx",

      "name": "Layout.tsx",

      "content":

        "import { useEffect } from &#39;react&#39;; import Navbar from &#39;./Navbar&#39;; import Footer from &#39;./Footer&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; import { useRouter } from &#39;next/router&#39;; import PageLoader from &#39;./PageLoader&#39;; type LayoutProps = { children: React.ReactNode; }; export default function Layout({ children }: LayoutProps) { const { isLoading, isAuthenticated } = useAuth(); const router = useRouter(); useEffect(() =&gt; { if (!isLoading &amp;&amp; !isAuthenticated()) { void router.push(&#39;/login&#39;); } }, [isLoading, isAuthenticated]); if (isLoading || !isAuthenticated()) { return &lt;PageLoader /&gt;; } return ( &lt;&gt; &lt;Navbar /&gt; &lt;main style={{ minHeight: &#39;calc(100vh - 72px - 32px - 64px)&#39; }}&gt; {children} &lt;/main&gt; &lt;Footer /&gt; &lt;/&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/DeleteAllFileModel.tsx",

      "name": "DeleteAllFileModel.tsx",

      "content":

        "import { useAuth } from &#39;@/contexts/AuthContext&#39;; import { Button, Modal, ModalOverlay, ModalContent, ModalHeader, ModalCloseButton, ModalBody, ModalFooter, Text, } from &#39;@chakra-ui/react&#39;; import { useMutation, useQueryClient } from &#39;react-query&#39;; import resultService from &#39;@/services/result&#39;; type DeleteFileModalProps = { isOpen: boolean; onClose: () =&gt; void; }; export default function DeleteAllFileModal({ isOpen, onClose, }: DeleteFileModalProps) { const { getToken } = useAuth(); const queryClient = useQueryClient(); const deleteMutation = useMutation(resultService.deleteAllResult); function handleDeleteAll() { deleteMutation.mutate( { token: getToken() }, { onSuccess: async () =&gt; { await queryClient.invalidateQueries(&#39;results&#39;); }, } ); onClose(); } return ( &lt;&gt; &lt;Modal isCentered isOpen={isOpen} onClose={onClose}&gt; &lt;ModalOverlay /&gt; &lt;ModalContent&gt; &lt;ModalHeader&gt;Confirm Delete&lt;/ModalHeader&gt; &lt;ModalCloseButton /&gt; &lt;ModalBody&gt; &lt;Text&gt;Are you sure you want to delete all results?&lt;/Text&gt; &lt;/ModalBody&gt; &lt;ModalFooter&gt; &lt;Button variant={&#39;outline-secondary&#39;} mr={3} onClick={onClose}&gt; Cancel &lt;/Button&gt; &lt;Button colorScheme=&quot;red&quot; onClick={handleDeleteAll}&gt; Delete &lt;/Button&gt; &lt;/ModalFooter&gt; &lt;/ModalContent&gt; &lt;/Modal&gt; &lt;/&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/PageLoader.tsx",

      "name": "PageLoader.tsx",

      "content":

        "import { Flex } from &#39;@chakra-ui/react&#39;; export default function PageLoader() { return &lt;Flex minW={&#39;100vw&#39;} minH={&#39;100vh&#39;}&gt;&lt;/Flex&gt;; } "

    },

    {

      "path": "recaption-application-main/components/ProcessingRecaptionModal.tsx",

      "name": "ProcessingRecaptionModal.tsx",

      "content":

        "import { Flex, Modal, ModalBody, ModalContent, ModalOverlay, Spinner, Text, } from &#39;@chakra-ui/react&#39;; type Props = { isOpenProcessing: boolean; onCloseProcessing: () =&gt; void; }; export default function ProcessingRecaptionModal({ isOpenProcessing, onCloseProcessing, }: Props) { return ( &lt;Modal closeOnOverlayClick={false} size={&#39;md&#39;} isOpen={isOpenProcessing} onClose={onCloseProcessing} &gt; &lt;ModalOverlay /&gt; &lt;ModalContent&gt; &lt;ModalBody borderRadius={&#39;12px&#39;} p={0}&gt; &lt;Flex flexDir={&#39;column&#39;} boxSize={&#39;sm&#39;} justify={&#39;center&#39;} alignItems={&#39;center&#39;} w={&#39;full&#39;} &gt; &lt;Spinner thickness=&quot;4px&quot; color=&quot;green.400&quot; size=&quot;xl&quot; /&gt; &lt;Text mt={10} color={&#39;green.400&#39;} fontSize={24}&gt; Processing... &lt;/Text&gt; &lt;/Flex&gt; &lt;/ModalBody&gt; &lt;/ModalContent&gt; &lt;/Modal&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/WithProtectedAdmin.tsx",

      "name": "WithProtectedAdmin.tsx",

      "content":

        "import { useAuth } from &#39;@/contexts/AuthContext&#39;; import { NextPageWithLayout } from &#39;@/pages/_app&#39;; import { Flex, Text } from &#39;@chakra-ui/react&#39;; export const WithProtectedAdmin = (Component: NextPageWithLayout) =&gt; { const Wrapper = () =&gt; { const { getUser } = useAuth(); if (getUser().role !== &#39;admin&#39;) { return ( &lt;Flex justify={&#39;center&#39;}&gt; &lt;Text mt={20} fontSize={&#39;2xl&#39;}&gt; Unauthorized. You can not access this page. &lt;/Text&gt; &lt;/Flex&gt; ); } return &lt;Component /&gt;; }; return Wrapper; }; "

    },

    {

      "path": "recaption-application-main/components/recognizer-result/ChangeValueModal.tsx",

      "name": "ChangeValueModal.tsx",

      "content":

        "import { useResultStore } from &#39;@/stores&#39;; import { Modal, ModalOverlay, ModalContent, ModalCloseButton, ModalBody, Input, Button, Flex, HStack, ModalHeader, useToast, } from &#39;@chakra-ui/react&#39;; import { useEffect, useState } from &#39;react&#39;; import resultService from &#39;@/services/result&#39;; import { useMutation } from &#39;react-query&#39;; import { useRouter } from &#39;next/router&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; type ChangeValueModalProps = { isOpenChangeValueModal: boolean; onCloseChangeValueModal: () =&gt; void; nearestObject: NearestObject | null; }; export default function ChangeValueModal({ isOpenChangeValueModal, onCloseChangeValueModal, nearestObject, }: ChangeValueModalProps) { const { getToken } = useAuth(); const toast = useToast(); const router = useRouter(); const { fileId } = router.query; const updateMutation = useMutation(resultService.updateResult); const [value, setValue] = useState(nearestObject?.value?.content || null); const result = useResultStore((state) =&gt; state.result); const setResult = useResultStore((state) =&gt; state.setResult); useEffect(() =&gt; { setValue(nearestObject?.value?.content || null); }, [nearestObject]); function handleSave() { let field = &#39;&#39;; const newResult = result.pages.map((page) =&gt; { const newKeyValuePair = page.key_value_pairs.map((res) =&gt; { if (res.key.content === nearestObject?.key?.content) { field = res.key.content; if (value) { res.value.content = value; } } return res; }); return { ...page, key_value_pairs: newKeyValuePair }; }); setResult({ pages: newResult }); updateMutation.mutate( {token: getToken(), resultId: fileId as string, result: { pages: newResult }}, { onSuccess: () =&gt; { toast({ title: &#39;Update Success&#39;, description: `Field ${field} is updated to &#39;${value || &quot;&quot;}&#39;`, status: &#39;success&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); }, onError: () =&gt; { toast({ title: &#39;Update Failed&#39;, description: `Failed to update field ${field}.&#39;`, status: &#39;error&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); } } ) onCloseChangeValueModal(); } function handleCancel() { onCloseChangeValueModal(); } return ( &lt;Modal isOpen={isOpenChangeValueModal} onClose={onCloseChangeValueModal}&gt; &lt;ModalOverlay /&gt; &lt;ModalContent&gt; &lt;ModalCloseButton /&gt; &lt;ModalHeader&gt;Enter new value:&lt;/ModalHeader&gt; &lt;ModalBody mt={-1}&gt; &lt;Input value={value || &#39;&#39;} onChange={(e) =&gt; setValue(e.target.value)} /&gt; &lt;Flex justify={&#39;flex-end&#39;} mb={3}&gt; &lt;HStack alignSelf={&#39;center&#39;} mt={4}&gt; &lt;Button variant={&#39;outline-secondary&#39;} mr={1} onClick={handleCancel} &gt; Cancel &lt;/Button&gt; &lt;Button variant={&#39;solid-primary&#39;} onClick={handleSave}&gt; Save &lt;/Button&gt; &lt;/HStack&gt; &lt;/Flex&gt; &lt;/ModalBody&gt; &lt;/ModalContent&gt; &lt;/Modal&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/recognizer-result/ImageBoundingBox.tsx",

      "name": "ImageBoundingBox.tsx",

      "content":

        "import { getBoundingBoxFromResult, drawAll, fillRectangle, isPointInsideRectangle, } from &#39;@/lib/boundingBox&#39;; import { getFileExtensionFromPath } from &#39;@/lib/file&#39;; import { useFileStore, useResultStore } from &#39;@/stores&#39;; import { Flex, Image, useDisclosure } from &#39;@chakra-ui/react&#39;; import { useState, useEffect } from &#39;react&#39;; import ChangeValueModal from &#39;./ChangeValueModal&#39;; export type ImageBoundingBoxProps = { fileUrl: string; resultContainerWidth: number; }; export default function ImageBoundingBox({ fileUrl, resultContainerWidth, }: ImageBoundingBoxProps) { const result = useResultStore((state) =&gt; state.result); const documentType = useFileStore((state) =&gt; state.documentType); const [imageWidth, setImageWidth] = useState(0); const [imageheight, setImageHeight] = useState(0); const [imageScale, setImageScale] = useState&lt;number | null&gt;(null); const [boundingBoxScale, setBoundingBoxScale] = useState&lt;number | null&gt;(null); const [originalImageWidth, setOriginalImageWidth] = useState&lt;number | null&gt;( null ); const [originalImageClientWidth, setOriginalImageClientWidth] = useState&lt; number | null &gt;(null); const [boundingBoxes, setBoundingBoxes] = useState( getBoundingBoxFromResult(result.pages[0], documentType) ); const [nearestObject, setNearestObject] = useState&lt;NearestObject | null&gt;( {} as NearestObject ); const [localMousePos, setLocalMousePos] = useState&lt;Coordinate&gt;( {} as Coordinate ); const { isOpen: isOpenChangeValueModal, onOpen: onOpenChangeValueModal, onClose: onCloseChangeValueModal, } = useDisclosure(); const fileType = getFileExtensionFromPath(fileUrl); /** * Set bounding boxes data based on recognizer result. */ useEffect(() =&gt; { setBoundingBoxes(getBoundingBoxFromResult(result.pages[0], documentType)); }, [result]); /** * Re-draw bounding boxes if there is changes in image scale (by zooming in or * out the image), this takes account the responsiveness based on image scale * and bounding box scale. */ useEffect(() =&gt; { if (imageScale &amp;&amp; boundingBoxScale) { drawAll(boundingBoxes, fileType, imageScale * boundingBoxScale); } }, [boundingBoxScale, boundingBoxes, fileType, imageScale]); /** * Render image and bounding box, considering that the document must be * displayed with full height for the first time. */ useEffect(() =&gt; { if (originalImageClientWidth &amp;&amp; originalImageWidth) { setBoundingBoxScale(originalImageClientWidth / originalImageWidth); // This make sure that the width of image will not exceed the width of the result container if (resultContainerWidth &gt; originalImageWidth) { if (originalImageClientWidth &gt;= originalImageWidth) { setImageScale(1); } else { setImageScale(originalImageWidth / originalImageClientWidth); } } else { setImageScale((resultContainerWidth - 50) / originalImageClientWidth); } } }, [originalImageClientWidth, originalImageWidth, resultContainerWidth]); /** * Make sure that the bounding box object have hover effect in the background when the mouse cursor is inside it */ useEffect(() =&gt; { const isCanvasExist = document.getElementById(&#39;boundingBoxes&#39;); if (isCanvasExist) { const canvas = document.getElementById( &#39;boundingBoxes&#39; ) as HTMLCanvasElement; const context = canvas.getContext(&#39;2d&#39;) as CanvasRenderingContext2D; context.clearRect(0, 0, imageCanvasWidth, imageCanvasHeight); if (imageScale &amp;&amp; boundingBoxScale) { drawAll(boundingBoxes, fileType, imageScale * boundingBoxScale); if (nearestObject?.value &amp;&amp; nearestObject.value.type !== &#39;table&#39;) { fillRectangle({ coordinates: nearestObject.value.polygon, color: nearestObject.value.color, documentScale: imageScale * boundingBoxScale, fileType, }); } } } }, [nearestObject]); /** * Set the nearest bounding box value in nearestObject state */ function findNearestBoundingBox() { if (imageScale &amp;&amp; boundingBoxScale) { const nearestBoxes = boundingBoxes.filter((item) =&gt; { const [p1, p2, p3, p4] = item.polygon; return isPointInsideRectangle( p1, p2, p3, p4, { x: localMousePos.x, y: localMousePos.y, }, imageScale * boundingBoxScale, &#39;image&#39; ); }); setNearestObject( { key: nearestBoxes[0], value: nearestBoxes[1] } || null ); } } /** * Handler function that will run when mouse is moving around the canvas element. It will set the mouse coordinate and update the nearest bounding box which is passed by the mouse */ function handleMouseMoveRelative(event: React.MouseEvent&lt;HTMLElement&gt;) { const domObject = event.currentTarget as HTMLElement; const bounds: DOMRect = domObject.getBoundingClientRect(); const x = event.clientX - bounds.left; const y = event.clientY - bounds.top; setLocalMousePos({ x: x, y: y }); findNearestBoundingBox(); } /** * Handler function to show change value modal when mouse perform onClick event inside the bounding box */ function handleMouseClick(nearestObject: BoundingBox | null) { if (nearestObject) { onOpenChangeValueModal(); } } const imageCanvasWidth = imageWidth * (imageScale || 1); const imageCanvasHeight = imageheight * (imageScale || 1); return ( &lt;&gt; &lt;ChangeValueModal isOpenChangeValueModal={isOpenChangeValueModal} onCloseChangeValueModal={onCloseChangeValueModal} nearestObject={nearestObject} /&gt; &lt;Flex pos={&#39;relative&#39;} mt={4} justify={&#39;center&#39;} onClick={() =&gt; handleMouseClick(nearestObject?.value || null)} &gt; &lt;canvas onMouseMove={handleMouseMoveRelative} id=&quot;boundingBoxes&quot; width={imageCanvasWidth} height={imageCanvasHeight} style={{ position: &#39;absolute&#39;, top: 0, zIndex: 1, cursor: nearestObject?.value ? &#39;pointer&#39; : &#39;auto&#39;, }} /&gt; &lt;Image onLoad={(node): void =&gt; { const element = node.target as HTMLImageElement; setImageWidth(element.clientWidth); setImageHeight(element.clientHeight); setOriginalImageWidth(element.naturalWidth); setOriginalImageClientWidth(element.clientWidth); }} src={fileUrl} alt=&quot;anotated-result&quot; /&gt; &lt;/Flex&gt; &lt;/&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/recognizer-result/ResultBoundingBox.tsx",

      "name": "ResultBoundingBox.tsx",

      "content":

        "import { useLayoutEffect, useRef, useState } from &#39;react&#39;; import { Flex, Button, Text } from &#39;@chakra-ui/react&#39;; import ChangeFileIcon from &#39;../ChangeFileIcon&#39;; import { useRouter } from &#39;next/router&#39;; import { getFileExtensionFromPath } from &#39;@/lib/file&#39;; import PdfBoundingBox from &#39;./PdfBoundingBox&#39;; import ImageBoundingBox from &#39;./ImageBoundingBox&#39;; export interface ResultBoundingBoxProps { fileUrl: string; } export default function ResultBoundingBox({ fileUrl }: ResultBoundingBoxProps) { const router = useRouter(); const fileExtension = getFileExtensionFromPath(fileUrl); const resultContainer = useRef&lt;HTMLDivElement&gt;(null); const [resultContainerWidth, _resultContainerWHeight] = useWindowSize(); /** * Custom hooks to detect the size of bounding box container * (PdfBoundingBox or ImageBoundingBox element), referred in * resultContainer variable using useRef hook * @returns referred element width and height */ function useWindowSize() { const [size, setSize] = useState([0, 0]); useLayoutEffect(() =&gt; { function updateSize() { if ( resultContainer.current?.getBoundingClientRect().width &amp;&amp; resultContainer.current?.getBoundingClientRect().height ) { setSize([ resultContainer.current?.getBoundingClientRect().width, resultContainer.current?.getBoundingClientRect().height, ]); } } window.addEventListener(&#39;resize&#39;, updateSize); updateSize(); return () =&gt; window.removeEventListener(&#39;resize&#39;, updateSize); }, []); return size; } /** * @returns bounding box element based on file extension */ function boundingBoxElement(fileExtension: string) { let element = null; if (fileExtension === &#39;pdf&#39;) { element = ( &lt;PdfBoundingBox fileUrl={fileUrl} resultContainerWidth={resultContainerWidth} /&gt; ); } else if ( fileExtension === &#39;jpg&#39; || fileExtension === &#39;jpeg&#39; || fileExtension === &#39;png&#39; ) { element = ( &lt;ImageBoundingBox fileUrl={fileUrl} resultContainerWidth={resultContainerWidth} /&gt; ); } return element; } return ( &lt;Flex ref={resultContainer} flexDir={&#39;column&#39;} w={&#39;50%&#39;} bg={&#39;#F8F8F8&#39;} px={6} pt={&#39;22px&#39;} pb={6} mr={6} &gt; &lt;Text fontWeight={500}&gt;File Scanned&lt;/Text&gt; {boundingBoxElement(fileExtension)} &lt;Button leftIcon={&lt;ChangeFileIcon /&gt;} variant={&#39;outline-primary&#39;} mt={4} w={&#39;117px&#39;} alignSelf={&#39;center&#39;} onClick={() =&gt; void router.push(&#39;/&#39;)} &gt; &lt;Text fontSize={14} fontWeight={400}&gt; Change File &lt;/Text&gt; &lt;/Button&gt; &lt;/Flex&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/recognizer-result/ResultRightContainer.tsx",

      "name": "ResultRightContainer.tsx",

      "content":

        "import { Flex, Tabs, TabList, Tab, TabPanels, TabPanel, Text, } from &#39;@chakra-ui/react&#39;; import ResultTable from &#39;./ResultTable&#39;; import { JSONTree } from &#39;react-json-tree&#39;; import AdditionalTable from &#39;./AdditionalTable&#39;; const theme = { scheme: &#39;monokai&#39;, author: &#39;wimer hazenberg (http://www.monokai.nl)&#39;, base00: &#39;#272822&#39;, base01: &#39;#383830&#39;, base02: &#39;#49483e&#39;, base03: &#39;#75715e&#39;, base04: &#39;#a59f85&#39;, base05: &#39;#f8f8f2&#39;, base06: &#39;#f5f4f1&#39;, base07: &#39;#f9f8f5&#39;, base08: &#39;#f92672&#39;, base09: &#39;#fd971f&#39;, base0A: &#39;#f4bf75&#39;, base0B: &#39;#a6e22e&#39;, base0C: &#39;#a1efe4&#39;, base0D: &#39;#66d9ef&#39;, base0E: &#39;#ae81ff&#39;, base0F: &#39;#cc6633&#39;, }; export default function ResultRightContainer({ result, }: { result: FormattedResult; }) { return ( &lt;Flex flexDir={&#39;column&#39;} border={&#39;1px&#39;} borderColor={&#39;gray.200&#39;} borderRadius={&#39;8px&#39;} p={6} pb={5} justify={&#39;space-between&#39;} w={&#39;50%&#39;} &gt; &lt;Flex flexDir={&#39;column&#39;}&gt; &lt;Text fontWeight={500}&gt;Recognizer Result&lt;/Text&gt; &lt;Tabs variant={&#39;enclosed&#39;} mt={6}&gt; &lt;TabList&gt; &lt;Tab _active={{ color: &#39;green.400&#39; }} color={&#39;green.400&#39;}&gt; Result &lt;/Tab&gt; &lt;Tab _active={{ color: &#39;green.400&#39; }} color={&#39;green.400&#39;}&gt; Table &lt;/Tab&gt; &lt;Tab _active={{ color: &#39;green.400&#39; }} color={&#39;green.400&#39;}&gt; JSON &lt;/Tab&gt; &lt;/TabList&gt; &lt;TabPanels&gt; &lt;TabPanel&gt; &lt;ResultTable /&gt; &lt;/TabPanel&gt; &lt;TabPanel&gt; &lt;AdditionalTable result={result} /&gt; &lt;/TabPanel&gt; &lt;TabPanel border={&#39;1px solid&#39;} borderColor={&#39;gray.200&#39;}&gt; &lt;JSONTree data={result} theme={theme} invertTheme={true} hideRoot={true} /&gt; &lt;/TabPanel&gt; &lt;/TabPanels&gt; &lt;/Tabs&gt; &lt;/Flex&gt; &lt;/Flex&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/recognizer-result/PdfBoundingBox.tsx",

      "name": "PdfBoundingBox.tsx",

      "content":

        "import { Flex, HStack, IconButton, Text, useDisclosure, } from &#39;@chakra-ui/react&#39;; import { Dispatch, SetStateAction, Ref, useState, useCallback, useLayoutEffect, useEffect, useRef, } from &#39;react&#39;; import { PiMagnifyingGlassMinusLight, PiMagnifyingGlassPlus, } from &#39;react-icons/pi&#39;; import { Document, Page, pdfjs } from &#39;react-pdf&#39;; import PdfPageNumber from &#39;../PdfPageNumber&#39;; import { useFileStore, usePageStore, useResultStore } from &#39;@/stores&#39;; import { getBoundingBoxFromResult, drawAll, fillRectangle, isPointInsideRectangle, } from &#39;@/lib/boundingBox&#39;; import { getFileExtensionFromPath } from &#39;@/lib/file&#39;; import type { PDFDocumentProxy } from &#39;pdfjs-dist&#39;; import ChangeValueModal from &#39;./ChangeValueModal&#39;; type PdfBoundingBoxProps = { fileUrl: string; resultContainerWidth: number; }; export default function PdfBoundingBox({ fileUrl, resultContainerWidth, }: PdfBoundingBoxProps) { const result = useResultStore((state) =&gt; state.result); const fileType = getFileExtensionFromPath(fileUrl); const documentType = useFileStore((state) =&gt; state.documentType); const [pdfWidth, setPdfWidth] = useState(0); const [pdfHeight, setPdfHeight] = useState(0); const [pdfScreenHeight, setPdfScreenHeight] = useState&lt;number&gt;(0); const firstRender = useRef(true); const [pdfScale, setPdfScale] = useState(1); const [boundingBoxScale, setBoundingBoxScale] = useState(1); const htmlCanvasWidth = pdfScreenHeight ? pdfWidth * (pdfScreenHeight / pdfHeight) * pdfScale : 0; const htmlCanvasHeight = pdfScreenHeight ? pdfScreenHeight * pdfScale : 0; const [viewportWidth, _viewportHeight] = useWindowSize(); const viewportMaxWidth = window.screen.availWidth; const [pdfPageTotal, setPdfPageTotal] = useState&lt;number | null&gt;(null); const pageNumber = usePageStore((state) =&gt; state.pageNumber); const setPageNumber = usePageStore((state) =&gt; state.setPageNumber); const [nearestObject, setNearestObject] = useState&lt;NearestObject | null&gt;( {} as NearestObject ); const [localMousePos, setLocalMousePos] = useState&lt;Coordinate&gt;( {} as Coordinate ); const { isOpen: isOpenChangeValueModal, onOpen: onOpenChangeValueModal, onClose: onCloseChangeValueModal, } = useDisclosure(); const reactPdfCanvas = useCallback((node: HTMLCanvasElement | null) =&gt; { if (node !== null &amp;&amp; firstRender.current === true) { setPdfScreenHeight(window.innerHeight - node.getBoundingClientRect().top); firstRender.current = false; } }, []); const [boundingBoxes, setBoundingBoxes] = useState( getBoundingBoxFromResult(result.pages[pageNumber - 1], documentType) ); useEffect(() =&gt; { // react-pdf use 1 index for page number, while our result use 0 index setBoundingBoxes( getBoundingBoxFromResult(result.pages[pageNumber - 1], documentType) ); }, [pageNumber, result.pages]); useEffect(() =&gt; { drawAll(boundingBoxes, fileType, pdfScale * boundingBoxScale); }, [boundingBoxScale, boundingBoxes, fileType, pdfScale]); useEffect(() =&gt; { if (resultContainerWidth) { if ( viewportWidth === viewportMaxWidth &amp;&amp; resultContainerWidth &gt; pdfWidth ) { setPdfScale(1); } else { setPdfScale( (resultContainerWidth - 50) / (pdfWidth * (pdfScreenHeight / pdfHeight)) ); } } }, [ viewportWidth, viewportMaxWidth, resultContainerWidth, pdfScreenHeight, pdfWidth, pdfHeight, ]); useEffect(() =&gt; { setBoundingBoxScale(pdfScreenHeight / pdfHeight); }, [pdfHeight, pdfScreenHeight]); useEffect(() =&gt; { const isCanvasExist = document.getElementById(&#39;boundingBoxes&#39;); if (isCanvasExist) { const canvas = document.getElementById( &#39;boundingBoxes&#39; ) as HTMLCanvasElement; const context = canvas.getContext(&#39;2d&#39;) as CanvasRenderingContext2D; context.clearRect(0, 0, htmlCanvasWidth, htmlCanvasHeight); drawAll(boundingBoxes, fileType, pdfScale * boundingBoxScale); if (nearestObject?.value &amp;&amp; nearestObject.value.type !== &#39;table&#39;) { fillRectangle({ coordinates: nearestObject.value.polygon, color: nearestObject.value.color, documentScale: pdfScale * boundingBoxScale, fileType, }); } } }, [nearestObject]); function findNearestBoundingBox() { const nearestBoxes = boundingBoxes.filter((item) =&gt; { const [p1, p2, p3, p4] = item.polygon; return isPointInsideRectangle( p1, p2, p3, p4, { x: localMousePos.x, y: localMousePos.y, }, pdfScale * boundingBoxScale, fileType ); }); setNearestObject({ key: nearestBoxes[0], value: nearestBoxes[1] } || null); } function handleMouseClick(nearestObject: BoundingBox | null) { if (nearestObject) { onOpenChangeValueModal(); } } function handleMouseMoveRelative(event: React.MouseEvent&lt;HTMLElement&gt;) { const domObject = event.currentTarget as HTMLElement; const bounds: DOMRect = domObject.getBoundingClientRect(); const x = event.clientX - bounds.left; const y = event.clientY - bounds.top; setLocalMousePos({ x: x, y: y }); findNearestBoundingBox(); } async function handleDocumentLoadSuccess(page: PDFDocumentProxy) { const pdfObj = await page.getPage(1); const widthIdx = pdfObj.rotate === 0 ? 2 : 3; const heightIdx = pdfObj.rotate === 0 ? 3 : 2; const width = pdfObj.view[widthIdx]; const height = pdfObj.view[heightIdx]; setPdfWidth(width); setPdfHeight(height); setPdfPageTotal(page.numPages); } pdfjs.GlobalWorkerOptions.workerSrc = `//unpkg.com/pdfjs-dist@${pdfjs.version}/build/pdf.worker.min.js`; return ( &lt;Flex flexDir={&#39;column&#39;}&gt; &lt;ChangeValueModal isOpenChangeValueModal={isOpenChangeValueModal} onCloseChangeValueModal={onCloseChangeValueModal} nearestObject={nearestObject} /&gt; &lt;Flex justify={&#39;center&#39;} mt={2}&gt; &lt;PdfPageNumber numPagesPDF={pdfPageTotal} pageNumberPDF={pageNumber} setPageNumberPDF={setPageNumber as Dispatch&lt;SetStateAction&lt;number&gt;&gt;} /&gt; &lt;HStack ml={6}&gt; &lt;IconButton aria-label=&quot;zoom-out&quot; variant={&#39;outline-secondary&#39;} icon={&lt;PiMagnifyingGlassMinusLight /&gt;} size={&#39;xs&#39;} fontSize={&#39;20px&#39;} onClick={() =&gt; setPdfScale((prev) =&gt; prev - 0.1)} /&gt; &lt;Text&gt;{Math.floor(pdfScale * 100)}%&lt;/Text&gt; &lt;IconButton aria-label=&quot;zoom-in&quot; variant={&#39;outline-secondary&#39;} icon={&lt;PiMagnifyingGlassPlus /&gt;} size={&#39;xs&#39;} fontSize={&#39;20px&#39;} isDisabled={htmlCanvasWidth &gt; resultContainerWidth - 100} onClick={() =&gt; setPdfScale((prev) =&gt; prev + 0.1)} /&gt; &lt;/HStack&gt; &lt;/Flex&gt; &lt;Flex pos={&#39;relative&#39;} mt={4} justify={&#39;center&#39;} onClick={() =&gt; handleMouseClick(nearestObject?.value || null)} &gt; &lt;canvas onMouseMove={handleMouseMoveRelative} id=&quot;boundingBoxes&quot; width={htmlCanvasWidth} height={htmlCanvasHeight} style={{ position: &#39;absolute&#39;, top: 0, zIndex: 1, cursor: nearestObject?.value ? &#39;pointer&#39; : &#39;auto&#39;, }} /&gt; &lt;Document file={fileUrl} onLoadSuccess={async (page: PDFDocumentProxy) =&gt; handleDocumentLoadSuccess(page) } &gt; &lt;Page canvasRef={reactPdfCanvas as Ref&lt;HTMLCanvasElement&gt;} scale={pdfScale} pageNumber={pageNumber} renderTextLayer={false} renderAnnotationLayer={false} height={pdfScreenHeight} &gt;&lt;/Page&gt; &lt;/Document&gt; &lt;/Flex&gt; &lt;/Flex&gt; ); } function useWindowSize() { const [size, setSize] = useState([0, 0]); useLayoutEffect(() =&gt; { function updateSize() { setSize([window.innerWidth, window.innerHeight]); } window.addEventListener(&#39;resize&#39;, updateSize); updateSize(); return () =&gt; window.removeEventListener(&#39;resize&#39;, updateSize); }, []); return size; } "

    },

    {

      "path": "recaption-application-main/components/recognizer-result/ResultTable.tsx",

      "name": "ResultTable.tsx",

      "content":

        "import { RowData, createColumnHelper, flexRender, getCoreRowModel, useReactTable, } from &#39;@tanstack/react-table&#39;; import { Flex, IconButton, Table, Tbody, Td, Th, Thead, Tr, useToast, Text, Textarea, } from &#39;@chakra-ui/react&#39;; import floatToPercentage from &#39;@/lib/util/floatToPercentage&#39;; import { useEffect, useState } from &#39;react&#39;; import { useFileStore, useResultStore } from &#39;@/stores&#39;; import { LuEdit } from &#39;react-icons/lu&#39;; import { MdCheck, MdClose } from &#39;react-icons/md&#39;; import { getKeyValuePairsFromPages } from &#39;@/lib/result&#39;; import { ExportExcel } from &#39;../ExportExcel&#39;; import resultService from &#39;@/services/result&#39;; import { useMutation } from &#39;react-query&#39;; import { useRouter } from &#39;next/router&#39;; import { useAuth } from &#39;@/contexts/AuthContext&#39;; declare module &#39;@tanstack/react-table&#39; { // eslint-disable-next-line @typescript-eslint/no-unused-vars interface TableMeta&lt;TData extends RowData&gt; { updateData: (rowIndex: number, columnId: string, value: unknown) =&gt; void; } } export type Result = { field: string; content: string; confidence: number | string; }; const columnHelper = createColumnHelper&lt;Result&gt;(); export const documentKeyOrder = { ktp: [ &#39;provinsi&#39;, &#39;kota_kabupaten&#39;, &#39;nik&#39;, &#39;nama&#39;, &#39;tempat_tanggal_lahir&#39;, &#39;jenis_kelamin&#39;, &#39;gol_darah&#39;, &#39;alamat&#39;, &#39;rt_rw&#39;, &#39;kel_desa&#39;, &#39;kecamatan&#39;, &#39;agama&#39;, &#39;status_perkawinan&#39;, &#39;pekerjaan&#39;, &#39;kewarganegaraan&#39;, &#39;berlaku_hingga&#39;, &#39;tanggal_pembuatan&#39;, ], passport: [ &#39;DocumentType&#39;, &#39;CountryRegion&#39;, &#39;DocumentNumber&#39;, &#39;FirstName&#39;, &#39;LastName&#39;, &#39;Nationality&#39;, &#39;DateOfBirth&#39;, &#39;Sex&#39;, &#39;PlaceOfBirth&#39;, &#39;IssuingAuthority&#39;, &#39;DateOfIssue&#39;, &#39;DateOfExpiration&#39;, &#39;MachineReadableZone&#39;, ], npwp: [&#39;no_npwp&#39;, &#39;nama&#39;, &#39;alamat&#39;], pajak: [ &#39;no_faktur&#39;, &#39;total_ppn&#39;, &#39;npwp_kena_pajak&#39;, &#39;pembeli_kena_pajak&#39;, &#39;tanggal_faktur_pajak&#39;, &#39;npwp_pembeli_kena_pajak&#39;, &#39;alamat_pembeli_kena_pajak&#39;, &#39;nama_pengusaha_kena_pajak&#39;, &#39;alamat_pengusaha_kena_pajak&#39;, ], invoice: [ &#39;bank&#39;, &#39;no_spk&#39;, &#39;deskripsi&#39;, &#39;no_invoice&#39;, &#39;grand_total&#39;, &#39;nama_partner&#39;, &#39;tanggal_invoice&#39;, ], }; function parseKeyValuePairs(key_value_pairs: key_value_pair[]) { if (key_value_pairs) { return key_value_pairs.map((res: key_value_pair) =&gt; { return { field: res.key.content, content: res.value ? res.value.content : &#39;&#39;, confidence: floatToPercentage(res.confidence), }; }); } else { return {}; } } export default function ResultTable() { const [excelData, setExcelData] = useState&lt;Result[]&gt;([]); const result = useResultStore((state) =&gt; state.result); const documentType = useFileStore((state) =&gt; state.documentType); const setResult = useResultStore((state) =&gt; state.setResult); const [data, setData] = useState&lt;Result[]&gt;( parseKeyValuePairs(getKeyValuePairsFromPages(result.pages)) as Result[] ); const { getToken } = useAuth(); const toast = useToast(); const router = useRouter(); const { fileId } = router.query; const updateMutation = useMutation(resultService.updateResult); function sortKey(key_value_pairs: key_value_pair[]) { let keyOrder: string[]; if (documentType === &#39;ktp&#39;) { keyOrder = documentKeyOrder.ktp; } else if (documentType === &#39;npwp&#39;) { keyOrder = documentKeyOrder.npwp; } else if (documentType === &#39;passport&#39;) { keyOrder = documentKeyOrder.passport; } else if (documentType === &#39;pajak&#39;) { keyOrder = documentKeyOrder.pajak; } else if (documentType === &#39;invoice&#39;) { keyOrder = documentKeyOrder.invoice; } return key_value_pairs.sort((a, b) =&gt; { const keyA = a.key.content; const keyB = b.key.content; const indexA = keyOrder.indexOf(keyA); const indexB = keyOrder.indexOf(keyB); return indexA - indexB; }); } useEffect(() =&gt; { const key_value_pairs = getKeyValuePairsFromPages(result.pages); if (key_value_pairs) { setData(parseKeyValuePairs(sortKey(key_value_pairs)) as Result[]); } }, [result]); useEffect(() =&gt; { setExcelData(data); }, [data]); const columns = [ columnHelper.accessor(&#39;field&#39;, { cell: (info) =&gt; info.getValue(), }), columnHelper.accessor(&#39;content&#39;, { cell: ({ getValue, row: { index }, column: { id }, table }) =&gt; { const initialValue = getValue(); // eslint-disable-next-line react-hooks/rules-of-hooks const [value, setValue] = useState(initialValue); // eslint-disable-next-line react-hooks/rules-of-hooks const [isEdit, setIsEdit] = useState(false); // If the initialValue is changed external, sync it up with our state // eslint-disable-next-line react-hooks/rules-of-hooks useEffect(() =&gt; { setValue(initialValue); }, [initialValue]); function handleSaveEdit() { table.options.meta?.updateData(index, id, value); const newResult = result.pages.map((page) =&gt; { const newKeyValuePair = page.key_value_pairs.map((res) =&gt; { if (res.key.content === data[index].field) { if (value) { res.value.content = value; } } return res; }); return { ...page, key_value_pairs: newKeyValuePair }; }); setResult({ pages: newResult }); updateMutation.mutate( { token: getToken(), resultId: fileId as string, result: { pages: newResult }, }, { onSuccess: () =&gt; { toast({ title: &#39;Update Success&#39;, description: `Field ${data[index].field} is updated to &#39;${value}&#39;`, status: &#39;success&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); }, onError: () =&gt; { toast({ title: &#39;Update Failed&#39;, description: `Failed to update field ${data[index].field}.&#39;`, status: &#39;error&#39;, duration: 3000, isClosable: true, position: &#39;top&#39;, }); }, } ); setIsEdit(false); } function handleCancelEdit() { setValue(initialValue); setIsEdit(false); } return ( &lt;Flex justify={&#39;space-between&#39;} align={&#39;center&#39;}&gt; {!isEdit &amp;&amp; &lt;Text&gt;{value}&lt;/Text&gt;} {isEdit ? ( &lt;Flex flexDir={&#39;column&#39;} w={&#39;full&#39;}&gt; &lt;Textarea value={value} onChange={(e) =&gt; setValue(e.target.value)} /&gt; &lt;Flex alignSelf={&#39;flex-end&#39;} mt={2}&gt; &lt;IconButton aria-label=&quot;Cancel&quot; icon={&lt;MdClose /&gt;} onClick={handleCancelEdit} size={&#39;sm&#39;} fontSize={&#39;18px&#39;} mr={2} _hover={{ bg: &#39;red.400&#39;, color: &#39;white&#39;, }} /&gt; &lt;IconButton aria-label=&quot;Save&quot; icon={&lt;MdCheck /&gt;} size={&#39;sm&#39;} onClick={handleSaveEdit} fontSize={&#39;18px&#39;} _hover={{ bg: &#39;green.300&#39;, color: &#39;white&#39;, }} /&gt; &lt;/Flex&gt; &lt;/Flex&gt; ) : ( &lt;IconButton aria-label=&quot;Edit Value&quot; icon={&lt;LuEdit /&gt;} onClick={() =&gt; setIsEdit(true)} /&gt; )} &lt;/Flex&gt; ); }, }), columnHelper.accessor(&#39;confidence&#39;, { cell: (info) =&gt; &lt;p&gt;{info.getValue()}%&lt;/p&gt;, }), ]; const table = useReactTable({ data, columns, getCoreRowModel: getCoreRowModel(), meta: { updateData: (rowIndex, columnId, value) =&gt; { setData((old) =&gt; { return old.map((row, index) =&gt; { if (index === rowIndex) { return { ...old[rowIndex], [columnId]: value, }; } return row; }); }); }, }, }); return ( &lt;Flex flexDir={&#39;column&#39;}&gt; &lt;Table&gt; &lt;Thead bg={&#39;gray.100&#39;}&gt; {table.getHeaderGroups().map((headerGroup) =&gt; ( &lt;Tr key={headerGroup.id}&gt; {headerGroup.headers.map((header) =&gt; ( &lt;Th px={6} py={4} key={header.id}&gt; {header.isPlaceholder ? null : flexRender( header.column.columnDef.header, header.getContext() )} &lt;/Th&gt; ))} &lt;/Tr&gt; ))} &lt;/Thead&gt; &lt;Tbody&gt; {table.getRowModel().rows.map((row) =&gt; ( &lt;Tr key={row.id}&gt; {row.getVisibleCells().map((cell) =&gt; ( &lt;Td py={4} borderColor={&#39;gray.200&#39;} key={cell.id} wordBreak={{ base: &#39;break-word&#39;, xl: // @ts-expect-error no accessorKey function in type cell.column.columnDef[&#39;accessorKey&#39;] === &#39;field&#39; ? &#39;normal&#39; : &#39;break-word&#39;, }} &gt; {flexRender(cell.column.columnDef.cell, cell.getContext())} &lt;/Td&gt; ))} &lt;/Tr&gt; ))} &lt;/Tbody&gt; &lt;/Table&gt; &lt;ExportExcel excelData={excelData} /&gt; &lt;/Flex&gt; ); } "

    },

    {

      "path": "recaption-application-main/components/recognizer-result/AdditionalTable.tsx",

      "name": "AdditionalTable.tsx",

      "content":

        "import { Divider, Flex, Table, TableContainer, Tbody, Td, Text, Th, Thead, Tr, } from &#39;@chakra-ui/react&#39;; import { ReactJSXElement } from &#39;@emotion/react/types/jsx-namespace&#39;; import React from &#39;react&#39;; type AdditionalTableProps = { result: FormattedResult; }; function createHeader(headers: string[]) { return headers.map((header, idx) =&gt; { return ( &lt;Th key={idx}&gt; &lt;Text wordBreak={&#39;break-all&#39;}&gt;{header}&lt;/Text&gt; &lt;/Th&gt; ); }); } function createRows(rows: { [key: string]: string }[]) { return rows.map((row, idx) =&gt; { return ( &lt;Tr key={idx}&gt; {Object.values(row).map((val, idx) =&gt; { return ( &lt;Td key={idx}&gt; &lt;Text wordBreak={&#39;break-all&#39;}&gt;{val}&lt;/Text&gt; &lt;/Td&gt; ); })} &lt;/Tr&gt; ); }); } export default function AdditionalTable({ result }: AdditionalTableProps) { const tables: FormattedTable[] = []; result.pages.forEach((page) =&gt; { tables.push(page.tables[0]); }); function getRowsFromTable(table: FormattedTable) { const dict: { [key: string]: string[] } = {}; const rows = []; if (table) { table.columns.forEach((col, idx) =&gt; { col.value.forEach((val) =&gt; { if (dict[idx]) { dict[idx] = [...dict[idx], val.content]; } else { dict[idx] = [val.content]; } }); }); const rowLength = dict[0].length; for (let i = 0; i &lt; rowLength; i++) { const row: { [key: string]: string } = {}; for (const key of Object.keys(dict)) { // @ts-expect-error key is string and dynamic // eslint-disable-next-line @typescript-eslint/no-unsafe-assignment, @typescript-eslint/no-unsafe-member-access const isHaveHeader: boolean = table.columns[key].header; if (isHaveHeader) { // @ts-expect-error key is string and dynamic // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access row[table.columns[key].header.content] = dict[key][i]; } else { row[`Column ${key}`] = dict[key][i]; } } rows.push(row); } } return rows; } const tableElmt: ReactJSXElement[] = []; tables.forEach((_table, idx) =&gt; { const rows = getRowsFromTable(_table); if (rows.length !== 0) { tableElmt.push( &lt;Flex key={`table-${idx}`} flexDir={&#39;column&#39;} mb={4}&gt; &lt;Text fontWeight={500}&gt;Page {idx + 1}&lt;/Text&gt; &lt;TableContainer mt={3}&gt; &lt;Table&gt; &lt;Thead bg={&#39;gray.100&#39;}&gt; &lt;Tr&gt;{createHeader(Object.keys(rows[0]))}&lt;/Tr&gt; &lt;/Thead&gt; &lt;Tbody&gt;{createRows(rows)}&lt;/Tbody&gt; &lt;/Table&gt; &lt;/TableContainer&gt; &lt;Divider mt={5} /&gt; &lt;/Flex&gt; ); } }); return ( &lt;&gt;{tableElmt.length &gt; 0 ? tableElmt : &lt;Text&gt;No table available&lt;/Text&gt;}&lt;/&gt; ); } "

    },

    {

      "path": "recaption-application-main/contexts/AuthContext.tsx",

      "name": "AuthContext.tsx",

      "content":

        "import { deleteCookie, getCookie, hasCookie, setCookie } from &#39;cookies-next&#39;; import jwtDecode from &#39;jwt-decode&#39;; import { useRouter } from &#39;next/router&#39;; import { createContext, useContext, useEffect, useState } from &#39;react&#39;; interface UserCredential { id: string; name: string; role: &#39;user&#39; | &#39;admin&#39;; } interface AuthContextData { isLoading: boolean; getUser: () =&gt; UserCredential; setUser: React.Dispatch&lt;React.SetStateAction&lt;UserCredential&gt;&gt;; getToken: () =&gt; string; setToken: React.Dispatch&lt;React.SetStateAction&lt;string&gt;&gt;; isAuthenticated: () =&gt; boolean; signIn: (token: string) =&gt; void; signOut: () =&gt; void; } interface ContextProps { children: React.ReactNode; } const AuthContext = createContext&lt;AuthContextData&gt;({} as AuthContextData); const AuthProvider: React.FC&lt;ContextProps&gt; = ({ children }) =&gt; { const router = useRouter(); const [user, setUser] = useState({} as UserCredential); const [isLoading, setIsLoading] = useState(true); const [token, setToken] = useState(&#39;&#39;); useEffect(() =&gt; { void initUser(); }, []); const initUser = () =&gt; { if (hasCookie(&#39;authToken&#39;)) { const userToken = getCookie(&#39;authToken&#39;); setToken(userToken as string); setUser(getDecodedUser(userToken as string)); } setIsLoading(false); }; const getDecodedUser = (token: string) =&gt; { const { id, name, role, ..._rest }: UserCredential = jwtDecode(token); return { id, name, role }; }; const signIn = (token: string) =&gt; { setToken(token); setCookie(&#39;authToken&#39;, token); setUser(getDecodedUser(token)); void router.push(&#39;/&#39;); }; const signOut = () =&gt; { setUser({} as UserCredential); setToken(&#39;&#39;); deleteCookie(&#39;authToken&#39;); void router.push(&#39;/login&#39;); }; return ( &lt;AuthContext.Provider value={{ isLoading, getUser: () =&gt; user, setUser, getToken: () =&gt; token, setToken, isAuthenticated: () =&gt; { return hasCookie(&#39;authToken&#39;); }, signIn, signOut, }} &gt; {children} &lt;/AuthContext.Provider&gt; ); }; const useAuth = () =&gt; { const context = useContext(AuthContext); if (!context) { throw new Error(&#39;Fail to load context from provider&#39;); } return context; }; export { AuthProvider, useAuth }; "

    }
  ]